#!/bin/bash

# ThyWill CLI - Git-style command-line utility for deployment and backup operations
# Usage: ./thywill <command> [options]

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DEPLOYMENT_DIR="$SCRIPT_DIR/deployment"
APP_DIR="/home/thywill/thywill"
BACKUP_DIR="/home/thywill/backups"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Logging functions
log() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

header() {
    echo -e "${BOLD}${CYAN}$1${NC}"
}

# Help functions
show_help() {
    header "ThyWill CLI - Deployment and Backup Management"
    echo ""
    echo "USAGE:"
    echo "    thywill <command> [options]"
    echo ""
    echo "COMMANDS:"
    echo ""
    header "  Development Commands:"
    echo "    start [port]        Start local development server (default: 8000)"
    echo ""
    header "  Deployment Commands:"
    echo "    deploy              Deploy application with automatic rollback"
    echo "    rollback [backup]   Rollback to previous version or specific backup"
    echo "    health              Check application health status"
    echo "    status              Show deployment and service status"
    echo "    logs [lines]        Show application logs (default: 50 lines)"
    echo ""
    header "  Backup Commands:"
    echo "    backup              Create database backup"
    echo "    list                List all available backups"
    echo "    restore <file>      Restore from specific backup file"
    echo "    cleanup             Clean up old backups"
    echo "    verify <file>       Verify backup integrity"
    echo ""
    header "  Admin Commands:"
    echo "    admin grant <name>      Grant admin role to user (by display name or ID)"
    echo "    admin revoke <name>     Revoke admin role from user"
    echo "    admin list              List all admin users"
    echo "    admin token [hours]     Create admin invite token"
    echo "    role list               List all available roles"
    echo "    role grant <user> <role> Grant specific role to user"
    echo "    role revoke <user> <role> Revoke specific role from user"
    echo "    import prayers <file>   Import prayers from JSON file"
    echo "    import community <file> Import community data from ZIP export"
    echo ""
    header "  Database Commands:"
    echo "    db init             Initialize database tables (first time only)"
    echo ""
    header "  Utility Commands:"
    echo "    setup               Complete development environment setup"
    echo "    init                Initialize deployment environment"
    echo "    install             Install thywill globally (no more ./)"
    echo "    uninstall           Remove global installation"
    echo "    config              Show current configuration"
    echo "    help                Show this help message"
    echo "    version             Show version information"
    echo ""
    echo "EXAMPLES:"
    echo "    thywill db init                                   # Initialize database (first time)"
    echo "    thywill setup                                     # Complete Ubuntu setup"
    echo "    thywill start                                     # Start dev server on port 8000"
    echo "    thywill admin grant \"John Smith\"                # Grant admin role"
    echo "    thywill role grant \"Jane Doe\" moderator         # Grant moderator role"
    echo "    thywill admin token 24                            # Create 24-hour admin token"
    echo "    thywill import prayers backup.json               # Import prayer data"
    echo "    thywill import community export.zip              # Import community export"
    echo "    thywill deploy                                    # Safe deployment"
    echo "    thywill backup                                    # Create database backup"
    echo "    thywill rollback                                  # Rollback to previous"
    echo "    thywill health                                    # Check app health"
    echo ""
    echo "For more information, see: deployment/DEPLOYMENT_GUIDE.md"
}

show_version() {
    echo "ThyWill CLI v1.0.0"
    echo "Deployment and Backup Management Utility"
    echo "Built for ThyWill Prayer Application"
}

# Development commands
cmd_start() {
    local port="${1:-8000}"
    local host="${2:-127.0.0.1}"
    
    header "Starting Development Server"
    
    # Check if we're in the right directory
    if [ ! -f "app.py" ]; then
        error "app.py not found in current directory"
        echo "Please run this command from your ThyWill project directory"
        exit 1
    fi
    
    # Check if virtual environment exists
    if [ ! -d "venv" ]; then
        warning "Virtual environment not found. Creating one..."
        python3 -m venv venv
        source venv/bin/activate
        pip install -r requirements.txt
    else
        log "Activating virtual environment..."
        source venv/bin/activate
    fi
    
    # Check if uvicorn is installed
    if ! python -c "import uvicorn" 2>/dev/null; then
        log "Installing uvicorn..."
        pip install uvicorn
    fi
    
    log "Starting development server on http://$host:$port"
    log "Press Ctrl+C to stop the server"
    echo ""
    
    # Start the development server
    exec uvicorn app:app --host "$host" --port "$port" --reload
}

# Deployment commands
cmd_deploy() {
    header "Starting Safe Deployment"
    
    if [ ! -f "$DEPLOYMENT_DIR/deploy.sh" ]; then
        error "Deployment script not found at $DEPLOYMENT_DIR/deploy.sh"
        exit 1
    fi
    
    log "Running deployment with automatic rollback..."
    cd "$SCRIPT_DIR"
    exec "$DEPLOYMENT_DIR/deploy.sh"
}

cmd_rollback() {
    local backup_file="${1:-}"
    
    header "Rolling Back Deployment"
    
    if [ -n "$backup_file" ]; then
        log "Rolling back to specific backup: $backup_file"
        "$DEPLOYMENT_DIR/backup_management.sh" restore "$backup_file"
    else
        log "Rolling back to most recent backup..."
        
        # Find most recent backup
        local latest_backup
        latest_backup=$(find "$BACKUP_DIR" -name "thywill_*.db" -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -d' ' -f2-)
        
        if [ -z "$latest_backup" ]; then
            error "No backups found for rollback"
            exit 1
        fi
        
        log "Found latest backup: $latest_backup"
        "$DEPLOYMENT_DIR/backup_management.sh" restore "$latest_backup"
    fi
}

cmd_health() {
    header "Application Health Check"
    
    log "Checking service status..."
    if systemctl is-active --quiet thywill; then
        success "ThyWill service is running"
    else
        error "ThyWill service is not running"
        echo "Run: sudo systemctl start thywill"
        exit 1
    fi
    
    log "Checking health endpoint..."
    if curl -f -s http://127.0.0.1:8000/health > /dev/null 2>&1; then
        success "Health endpoint responding"
        echo ""
        echo "Health Details:"
        curl -s http://127.0.0.1:8000/health | python3 -m json.tool 2>/dev/null || curl -s http://127.0.0.1:8000/health
    else
        error "Health endpoint not responding"
        warning "Application may be starting up or experiencing issues"
        cmd_logs 20
        exit 1
    fi
}

cmd_status() {
    header "System Status"
    
    echo ""
    log "Service Status:"
    systemctl status thywill --no-pager -l || true
    
    echo ""
    log "Recent Deployments:"
    if [ -d "/home/thywill/deploy_logs" ]; then
        ls -la /home/thywill/deploy_logs/ | tail -5 || echo "No deployment logs found"
    else
        echo "No deployment logs directory found"
    fi
    
    echo ""
    log "Backup Status:"
    if [ -d "$BACKUP_DIR" ]; then
        echo "Daily backups: $(find $BACKUP_DIR/daily -name "*.db" 2>/dev/null | wc -l) files"
        echo "Weekly backups: $(find $BACKUP_DIR/weekly -name "*.db" 2>/dev/null | wc -l) files"
        echo "Latest backup: $(find $BACKUP_DIR -name "thywill_*.db" -type f -printf '%T@ %p\n' 2>/dev/null | sort -n | tail -1 | cut -d' ' -f2- | xargs basename 2>/dev/null || echo 'None found')"
    else
        warning "Backup directory not found"
    fi
    
    echo ""
    log "Disk Usage:"
    df -h "$BACKUP_DIR" 2>/dev/null || df -h /home/thywill/ 2>/dev/null || df -h /home/
}

cmd_logs() {
    local lines="${1:-50}"
    
    header "Application Logs (last $lines lines)"
    
    if command -v journalctl >/dev/null 2>&1; then
        journalctl -u thywill -n "$lines" --no-pager
    else
        error "journalctl not available. Check system logs manually."
        exit 1
    fi
}

# Backup commands
cmd_backup() {
    header "Creating Database Backup"
    "$DEPLOYMENT_DIR/backup_management.sh" daily
}

cmd_list() {
    header "Available Backups"
    "$DEPLOYMENT_DIR/backup_management.sh" list
}

cmd_restore() {
    local backup_file="${1:-}"
    
    if [ -z "$backup_file" ]; then
        error "Backup file path required"
        echo "Usage: thywill restore <backup_file>"
        echo "Use 'thywill list' to see available backups"
        exit 1
    fi
    
    header "Restoring from Backup"
    "$DEPLOYMENT_DIR/backup_management.sh" restore "$backup_file"
}

cmd_cleanup() {
    header "Cleaning Up Old Backups"
    "$DEPLOYMENT_DIR/backup_management.sh" cleanup
}

cmd_verify() {
    local backup_file="${1:-}"
    
    if [ -z "$backup_file" ]; then
        error "Backup file path required"
        echo "Usage: thywill verify <backup_file>"
        exit 1
    fi
    
    header "Verifying Backup Integrity"
    
    if [ ! -f "$backup_file" ]; then
        error "Backup file not found: $backup_file"
        exit 1
    fi
    
    log "Checking file integrity..."
    if [ -f "${backup_file}.sha256" ]; then
        if sha256sum -c "${backup_file}.sha256" > /dev/null 2>&1; then
            success "Checksum verification passed"
        else
            error "Checksum verification failed"
            exit 1
        fi
    else
        warning "No checksum file found, skipping checksum verification"
    fi
    
    log "Checking database integrity..."
    if sqlite3 "$backup_file" "PRAGMA integrity_check;" | grep -q "ok"; then
        success "Database integrity check passed"
    else
        error "Database integrity check failed"
        exit 1
    fi
    
    success "Backup verification completed successfully"
}

# Admin commands
cmd_admin() {
    local subcommand="${1:-}"
    shift || true
    
    case "$subcommand" in
        grant)
            cmd_admin_grant "$@"
            ;;
        revoke)
            cmd_admin_revoke "$@"
            ;;
        list)
            cmd_admin_list "$@"
            ;;
        token)
            cmd_admin_token "$@"
            ;;
        *)
            error "Unknown admin subcommand: $subcommand"
            echo "Available subcommands: grant, revoke, list, token"
            echo "Usage: thywill admin <subcommand> [args]"
            exit 1
            ;;
    esac
}

cmd_admin_grant() {
    local user_identifier="${1:-}"
    
    if [ -z "$user_identifier" ]; then
        error "User identifier required"
        echo "Usage: thywill admin grant <display_name_or_user_id>"
        echo "Examples:"
        echo "  thywill admin grant \"John Smith\""
        echo "  thywill admin grant abc123def456"
        exit 1
    fi
    
    header "Granting Admin Rights"
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ] && [ ! -f "thywill.db" ]; then
        error "Must run from ThyWill project directory"
        echo "Database or models.py not found"
        exit 1
    fi
    
    log "Looking up user: $user_identifier"
    
    # Run Python script to grant admin role
    python3 -c "
import sys
sys.path.append('.')
from sqlmodel import Session, select
from models import engine, User, Role, UserRole
from datetime import datetime

user_identifier = '$user_identifier'

def find_user(session, identifier):
    # First try exact ID match
    stmt = select(User).where(User.id == identifier)
    user = session.exec(stmt).first()
    
    if not user:
        # Try exact display_name match
        stmt = select(User).where(User.display_name == identifier)
        user = session.exec(stmt).first()
    
    if not user:
        # Try partial display_name match
        stmt = select(User).where(User.display_name.contains(identifier))
        users = list(session.exec(stmt))
        
        if not users:
            print(f'‚ùå No user found matching: {identifier}')
            print('   Available users:')
            # Show first 10 users as examples
            all_users = list(session.exec(select(User).limit(10)))
            for u in all_users:
                print(f'   - \"{u.display_name}\" (ID: {u.id[:8]}...)')
            if len(all_users) == 10:
                print('   ... (showing first 10 users)')
            return None
        elif len(users) > 1:
            print(f'‚ùå Multiple users found matching: {identifier}')
            print('   Be more specific. Found:')
            for u in users:
                print(f'   - \"{u.display_name}\" (ID: {u.id[:8]}...)')
            return None
        else:
            return users[0]
    
    return user

try:
    with Session(engine) as session:
        user = find_user(session, user_identifier)
        if not user:
            sys.exit(1)
        
        # Get admin role
        stmt = select(Role).where(Role.name == 'admin')
        admin_role = session.exec(stmt).first()
        
        if not admin_role:
            print('‚ùå Admin role not found. Run migration first: python migrate_to_roles.py')
            sys.exit(1)
        
        # Check if user already has admin role
        if user.has_role('admin', session):
            print(f'‚ÑπÔ∏è  User \"{user.display_name}\" already has admin role')
            sys.exit(0)
        
        # Check for backward compatibility (old system)
        if user.id == 'admin':
            print(f'‚ÑπÔ∏è  User \"{user.display_name}\" already has admin rights (old system)')
            print('   Run migration to convert to role-based system: python migrate_to_roles.py')
            sys.exit(0)
        
        # Grant admin role
        user_role = UserRole(
            user_id=user.id,
            role_id=admin_role.id,
            granted_by=None,  # CLI granted
            granted_at=datetime.utcnow()
        )
        session.add(user_role)
        session.commit()
        
        print(f'‚úÖ Admin role granted to: \"{user.display_name}\"')
        print(f'   User ID: {user.id[:8]}...')
        print('   ‚ú® Using new role-based permission system')

except Exception as e:
    print(f'‚ùå Error granting admin role: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
"
}

cmd_admin_revoke() {
    local user_identifier="${1:-}"
    
    if [ -z "$user_identifier" ]; then
        error "User identifier required"
        echo "Usage: thywill admin revoke <display_name_or_user_id>"
        echo "Examples:"
        echo "  thywill admin revoke \"John Smith\""
        echo "  thywill admin revoke abc123def456"
        exit 1
    fi
    
    header "Revoking Admin Role"
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ] && [ ! -f "thywill.db" ]; then
        error "Must run from ThyWill project directory"
        exit 1
    fi
    
    log "Looking up user: $user_identifier"
    
    python3 -c "
import sys
sys.path.append('.')
from sqlmodel import Session, select
from models import engine, User, Role, UserRole

user_identifier = '$user_identifier'

def find_user(session, identifier):
    # First try exact ID match
    stmt = select(User).where(User.id == identifier)
    user = session.exec(stmt).first()
    
    if not user:
        # Try exact display_name match
        stmt = select(User).where(User.display_name == identifier)
        user = session.exec(stmt).first()
    
    if not user:
        # Try partial display_name match
        stmt = select(User).where(User.display_name.contains(identifier))
        users = list(session.exec(stmt))
        
        if not users:
            print(f'‚ùå No user found matching: {identifier}')
            return None
        elif len(users) > 1:
            print(f'‚ùå Multiple users found matching: {identifier}')
            print('   Be more specific. Found:')
            for u in users:
                print(f'   - \"{u.display_name}\" (ID: {u.id[:8]}...)')
            return None
        else:
            return users[0]
    
    return user

try:
    with Session(engine) as session:
        user = find_user(session, user_identifier)
        if not user:
            sys.exit(1)
        
        # Get admin role
        stmt = select(Role).where(Role.name == 'admin')
        admin_role = session.exec(stmt).first()
        
        if not admin_role:
            print('‚ùå Admin role not found. Run migration first: python migrate_to_roles.py')
            sys.exit(1)
        
        # Check if user has admin role
        if not user.has_role('admin', session):
            print(f'‚ÑπÔ∏è  User \"{user.display_name}\" does not have admin role')
            sys.exit(0)
        
        # Remove admin role
        stmt = select(UserRole).where(
            UserRole.user_id == user.id,
            UserRole.role_id == admin_role.id
        )
        user_roles = session.exec(stmt).all()
        
        for user_role in user_roles:
            session.delete(user_role)
        
        session.commit()
        
        print(f'‚úÖ Admin role revoked from: \"{user.display_name}\"')
        print(f'   User ID: {user.id[:8]}...')
        print('   ‚ú® Using new role-based permission system')

except Exception as e:
    print(f'‚ùå Error revoking admin role: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
"
}

cmd_admin_list() {
    header "Admin Users"
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ] && [ ! -f "thywill.db" ]; then
        error "Must run from ThyWill project directory"
        exit 1
    fi
    
    python3 -c "
import sys
sys.path.append('.')
from sqlmodel import Session, select, func
from models import engine, User, Role, UserRole

try:
    with Session(engine) as session:
        # Try role-based system first
        try:
            stmt = select(User).join(UserRole, User.id == UserRole.user_id).join(Role, UserRole.role_id == Role.id).where(
                Role.name == 'admin',
                (UserRole.expires_at.is_(None)) | (UserRole.expires_at > func.datetime('now'))
            )
            admin_users = session.exec(stmt).all()
            
            if admin_users:
                print('üëë Admin Users (Role-based system):')
                for user in admin_users:
                    roles = user.get_roles(session)
                    role_names = [r.name for r in roles]
                    print(f'   ‚Ä¢ {user.display_name}')
                    print(f'     ID: {user.id[:8]}...')
                    print(f'     Roles: {\", \".join(role_names)}')
                    print(f'     Created: {user.created_at}')
                    print()
            else:
                print('‚ÑπÔ∏è  No admin users found in role-based system')
        except Exception as role_error:
            print('‚ö†Ô∏è  Role-based system not available (tables not created yet)')
            
        # Check old system for backward compatibility
        stmt = select(User).where(User.id == 'admin')
        old_admin = session.exec(stmt).first()
        
        if old_admin:
            print('üëë Admin User (Old system - needs migration):')
            print(f'   ‚Ä¢ {old_admin.display_name}')
            print(f'     ID: admin (legacy)')
            print(f'     Created: {old_admin.created_at}')
            print()
            print('üí° Run \"python migrate_to_roles.py\" to upgrade to role-based system')
        
        if not admin_users and not old_admin:
            print('‚ÑπÔ∏è  No admin users found')
            print('   Use \"thywill admin token\" to create an admin invite')

except Exception as e:
    print(f'‚ùå Error listing admins: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
"
}

cmd_admin_token() {
    local hours="${1:-12}"
    
    header "Creating Admin Invite Token"
    
    # Validate hours
    if ! [[ "$hours" =~ ^[0-9]+$ ]] || [ "$hours" -le 0 ]; then
        error "Hours must be a positive number"
        echo "Usage: thywill admin token [hours]"
        exit 1
    fi
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ] && [ ! -f "thywill.db" ]; then
        error "Must run from ThyWill project directory"
        exit 1
    fi
    
    log "Creating admin invite token (expires in $hours hours)..."
    
    python3 -c "
import sys
sys.path.append('.')
import uuid
import socket
import subprocess
import os
from datetime import datetime, timedelta
from sqlmodel import Session
from models import engine, InviteToken

hours = int('$hours')

def detect_environment_and_url():
    '''Automatically detect if running in development or production and return appropriate URL'''
    
    # Check if running in development (uvicorn process)
    try:
        # Check for uvicorn process
        result = subprocess.run(['pgrep', '-f', 'uvicorn.*app:app'], capture_output=True, text=True)
        if result.returncode == 0:
            # Development mode detected
            return 'http://127.0.0.1:8000', 'development'
    except:
        pass
    
    # Check if nginx is configured for this domain
    nginx_configs = [
        '/etc/nginx/sites-enabled/thywill',
        '/etc/nginx/sites-available/thywill'
    ]
    
    domain = None
    for config_path in nginx_configs:
        if os.path.exists(config_path):
            try:
                with open(config_path, 'r') as f:
                    content = f.read()
                    # Look for server_name directive
                    for line in content.split('\n'):
                        line = line.strip()
                        if line.startswith('server_name') and not 'your-domain.com' in line:
                            # Extract domain name
                            parts = line.split()
                            if len(parts) >= 2:
                                domain = parts[1].rstrip(';')
                                if domain != '_':  # Not default server
                                    return f'https://{domain}', 'production (domain)'
            except:
                pass
    
    # Check if nginx is running (IP-only setup)
    try:
        result = subprocess.run(['systemctl', 'is-active', 'nginx'], capture_output=True, text=True)
        if result.returncode == 0 and result.stdout.strip() == 'active':
            # Get external IP
            try:
                # Try to get external IP
                external_ip = subprocess.run(['curl', '-s', '--max-time', '3', 'ifconfig.me'], 
                                           capture_output=True, text=True).stdout.strip()
                if external_ip and external_ip.replace('.', '').isdigit():
                    return f'http://{external_ip}', 'production (IP)'
            except:
                pass
            
            # Fallback to local IP
            try:
                hostname = socket.gethostname()
                local_ip = socket.gethostbyname(hostname)
                return f'http://{local_ip}', 'production (local IP)'
            except:
                pass
    except:
        pass
    
    # Default fallback
    return 'http://your-server-ip', 'unknown'

try:
    # Generate token
    token = str(uuid.uuid4())
    expires_at = datetime.utcnow() + timedelta(hours=hours)
    
    # Save to database
    with Session(engine) as session:
        invite_token = InviteToken(
            token=token,
            created_by_user='system',  # System generated
            expires_at=expires_at,
            used=False
        )
        session.add(invite_token)
        session.commit()
    
    # Detect environment and build URL
    base_url, env_type = detect_environment_and_url()
    claim_url = f'{base_url}/claim/{token}'
    
    # Success output
    print('‚úÖ Admin invite token created successfully!')
    print(f'Token: {token}')
    print(f'Expires: {expires_at.strftime(\"%Y-%m-%d %H:%M:%S\")} UTC')
    print(f'Valid for: {hours} hours')
    print(f'Environment: {env_type}')
    print()
    print('üîó Claim URL:')
    print(f'   {claim_url}')
    print()
    
    # Environment-specific instructions
    if 'development' in env_type:
        print('üí° Development mode detected:')
        print('   1. Make sure your dev server is running: thywill start')
        print('   2. Visit the claim URL above')
        print('   3. Create your admin account')
    elif 'production' in env_type:
        print('üí° Production mode detected:')
        print('   1. Share this URL with the new admin')
        print('   2. They can create their admin account')
        print('   3. Token will expire automatically')
        if 'IP' in env_type:
            print('   ‚ö†Ô∏è  Using IP address - consider setting up a domain')
    else:
        print('üí° Manual setup required:')
        print('   1. Replace \"your-server-ip\" with your actual server address')
        print('   2. Visit the claim URL')
        print('   3. Create your admin account')
        
except Exception as e:
    print(f'‚ùå Error creating admin token: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
"
}

cmd_role() {
    local subcommand="${1:-}"
    shift || true
    
    case "$subcommand" in
        list)
            cmd_role_list "$@"
            ;;
        grant)
            cmd_role_grant "$@"
            ;;
        revoke)
            cmd_role_revoke "$@"
            ;;
        *)
            error "Unknown role subcommand: $subcommand"
            echo "Available subcommands: list, grant, revoke"
            echo "Usage: thywill role <subcommand> [args]"
            echo ""
            echo "Examples:"
            echo "  thywill role list"
            echo "  thywill role grant \"John Smith\" moderator"
            echo "  thywill role revoke \"John Smith\" moderator"
            exit 1
            ;;
    esac
}

cmd_role_list() {
    header "Available Roles"
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ] && [ ! -f "thywill.db" ]; then
        error "Must run from ThyWill project directory"
        exit 1
    fi
    
    python3 -c "
import sys
sys.path.append('.')
from sqlmodel import Session, select
from models import engine, Role, UserRole, User
import json

try:
    with Session(engine) as session:
        # Get all roles
        stmt = select(Role)
        roles = session.exec(stmt).all()
        
        if not roles:
            print('‚ÑπÔ∏è  No roles found. Run migration first: python migrate_to_roles.py')
            sys.exit(0)
        
        for role in roles:
            try:
                permissions = json.loads(role.permissions)
            except:
                permissions = []
            
            # Count users with this role
            stmt = select(UserRole).where(UserRole.role_id == role.id)
            user_count = len(list(session.exec(stmt)))
            
            system_marker = ' üîí' if role.is_system_role else ''
            
            print(f'üìã {role.name}{system_marker}')
            print(f'   Description: {role.description or \"No description\"}')
            print(f'   Users: {user_count}')
            print(f'   Permissions: {len(permissions)}')
            if permissions:
                perm_preview = ', '.join(permissions[:3])
                if len(permissions) > 3:
                    perm_preview += f' ... (+{len(permissions)-3} more)'
                print(f'              {perm_preview}')
            print()

except Exception as e:
    print(f'‚ùå Error listing roles: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
"
}

cmd_role_grant() {
    local user_identifier="${1:-}"
    local role_name="${2:-}"
    
    if [ -z "$user_identifier" ] || [ -z "$role_name" ]; then
        error "User and role required"
        echo "Usage: thywill role grant <user> <role>"
        echo "Examples:"
        echo "  thywill role grant \"John Smith\" moderator"
        echo "  thywill role grant abc123def456 user"
        exit 1
    fi
    
    header "Granting Role: $role_name"
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ] && [ ! -f "thywill.db" ]; then
        error "Must run from ThyWill project directory"
        exit 1
    fi
    
    log "Looking up user: $user_identifier"
    log "Role to grant: $role_name"
    
    python3 -c "
import sys
sys.path.append('.')
from sqlmodel import Session, select
from models import engine, User, Role, UserRole
from datetime import datetime

user_identifier = '$user_identifier'
role_name = '$role_name'

def find_user(session, identifier):
    # User lookup logic (same as admin commands)
    stmt = select(User).where(User.id == identifier)
    user = session.exec(stmt).first()
    
    if not user:
        stmt = select(User).where(User.display_name == identifier)
        user = session.exec(stmt).first()
    
    if not user:
        stmt = select(User).where(User.display_name.contains(identifier))
        users = list(session.exec(stmt))
        
        if not users:
            print(f'‚ùå No user found matching: {identifier}')
            return None
        elif len(users) > 1:
            print(f'‚ùå Multiple users found matching: {identifier}')
            for u in users:
                print(f'   - \"{u.display_name}\" (ID: {u.id[:8]}...)')
            return None
        else:
            return users[0]
    
    return user

try:
    with Session(engine) as session:
        user = find_user(session, user_identifier)
        if not user:
            sys.exit(1)
        
        # Get role
        stmt = select(Role).where(Role.name == role_name)
        role = session.exec(stmt).first()
        
        if not role:
            print(f'‚ùå Role \"{role_name}\" not found')
            print('   Available roles:')
            stmt = select(Role)
            all_roles = session.exec(stmt).all()
            for r in all_roles:
                print(f'   - {r.name}')
            sys.exit(1)
        
        # Check if user already has this role
        if user.has_role(role_name, session):
            print(f'‚ÑπÔ∏è  User \"{user.display_name}\" already has role \"{role_name}\"')
            sys.exit(0)
        
        # Grant role
        user_role = UserRole(
            user_id=user.id,
            role_id=role.id,
            granted_by=None,  # CLI granted
            granted_at=datetime.utcnow()
        )
        session.add(user_role)
        session.commit()
        
        print(f'‚úÖ Role \"{role_name}\" granted to: \"{user.display_name}\"')
        print(f'   User ID: {user.id[:8]}...')

except Exception as e:
    print(f'‚ùå Error granting role: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
"
}

cmd_role_revoke() {
    local user_identifier="${1:-}"
    local role_name="${2:-}"
    
    if [ -z "$user_identifier" ] || [ -z "$role_name" ]; then
        error "User and role required"
        echo "Usage: thywill role revoke <user> <role>"
        echo "Examples:"
        echo "  thywill role revoke \"John Smith\" moderator"
        echo "  thywill role revoke abc123def456 user"
        exit 1
    fi
    
    header "Revoking Role: $role_name"
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ] && [ ! -f "thywill.db" ]; then
        error "Must run from ThyWill project directory"
        exit 1
    fi
    
    log "Looking up user: $user_identifier"
    log "Role to revoke: $role_name"
    
    python3 -c "
import sys
sys.path.append('.')
from sqlmodel import Session, select
from models import engine, User, Role, UserRole

user_identifier = '$user_identifier'
role_name = '$role_name'

def find_user(session, identifier):
    # User lookup logic (same as admin commands)
    stmt = select(User).where(User.id == identifier)
    user = session.exec(stmt).first()
    
    if not user:
        stmt = select(User).where(User.display_name == identifier)
        user = session.exec(stmt).first()
    
    if not user:
        stmt = select(User).where(User.display_name.contains(identifier))
        users = list(session.exec(stmt))
        
        if not users:
            print(f'‚ùå No user found matching: {identifier}')
            return None
        elif len(users) > 1:
            print(f'‚ùå Multiple users found matching: {identifier}')
            for u in users:
                print(f'   - \"{u.display_name}\" (ID: {u.id[:8]}...)')
            return None
        else:
            return users[0]
    
    return user

try:
    with Session(engine) as session:
        user = find_user(session, user_identifier)
        if not user:
            sys.exit(1)
        
        # Get role
        stmt = select(Role).where(Role.name == role_name)
        role = session.exec(stmt).first()
        
        if not role:
            print(f'‚ùå Role \"{role_name}\" not found')
            sys.exit(1)
        
        # Check if user has this role
        if not user.has_role(role_name, session):
            print(f'‚ÑπÔ∏è  User \"{user.display_name}\" does not have role \"{role_name}\"')
            sys.exit(0)
        
        # Revoke role
        stmt = select(UserRole).where(
            UserRole.user_id == user.id,
            UserRole.role_id == role.id
        )
        user_roles = session.exec(stmt).all()
        
        for user_role in user_roles:
            session.delete(user_role)
        
        session.commit()
        
        print(f'‚úÖ Role \"{role_name}\" revoked from: \"{user.display_name}\"')
        print(f'   User ID: {user.id[:8]}...')

except Exception as e:
    print(f'‚ùå Error revoking role: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
"
}

cmd_import() {
    local import_type="${1:-}"
    local file_path="${2:-}"
    
    case "$import_type" in
        prayers)
            cmd_import_prayers "$file_path"
            ;;
        community)
            cmd_import_community "$file_path" "${@:3}"
            ;;
        *)
            error "Unknown import type: $import_type"
            echo "Available import types: prayers, community"
            echo "Usage: thywill import <type> <file> [options]"
            echo ""
            echo "Examples:"
            echo "  thywill import prayers backup.json"
            echo "  thywill import community export.zip"
            echo "  thywill import community export.zip --dry-run"
            exit 1
            ;;
    esac
}

cmd_import_prayers() {
    local file_path="${1:-}"
    
    if [ -z "$file_path" ]; then
        error "File path required"
        echo "Usage: thywill import prayers <json_file>"
        echo ""
        echo "Expected JSON format:"
        echo '['
        echo '  {'
        echo '    "text": "Prayer request text",'
        echo '    "generated_prayer": "Generated prayer response",'
        echo '    "author_name": "User Display Name",'
        echo '    "author_id": "existing_user_id (optional)",'
        echo '    "project_tag": "optional tag",'
        echo '    "target_audience": "all",'
        echo '    "created_at": "2023-12-01T10:00:00"'
        echo '  }'
        echo ']'
        exit 1
    fi
    
    if [ ! -f "$file_path" ]; then
        error "File not found: $file_path"
        exit 1
    fi
    
    header "Importing Prayers from $file_path"
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ] && [ ! -f "thywill.db" ]; then
        error "Must run from ThyWill project directory"
        exit 1
    fi
    
    log "Validating JSON file..."
    
    # Validate JSON first
    if ! python3 -c "import json; json.load(open('$file_path'))" 2>/dev/null; then
        error "Invalid JSON file"
        exit 1
    fi
    
    log "Importing prayers..."
    
    python3 -c "
import sys
sys.path.append('.')
import json
import uuid
from datetime import datetime
from sqlmodel import Session, select
from models import engine, User, Prayer

file_path = '$file_path'

try:
    with open(file_path, 'r') as f:
        prayers_data = json.load(f)
    
    if not isinstance(prayers_data, list):
        print('‚ùå JSON file must contain an array of prayer objects')
        sys.exit(1)
    
    imported_count = 0
    skipped_count = 0
    error_count = 0
    
    with Session(engine) as session:
        for i, prayer_data in enumerate(prayers_data):
            try:
                # Validate required fields
                if 'text' not in prayer_data:
                    print(f'‚ö†Ô∏è  Skipping prayer {i+1}: missing \"text\" field')
                    skipped_count += 1
                    continue
                
                # Find or create user by ID or display name
                author_id = prayer_data.get('author_id')
                author_name = prayer_data.get('author_name', 'Imported User')
                
                author = None
                
                # First try to find by existing ID
                if author_id:
                    stmt = select(User).where(User.id == author_id)
                    author = session.exec(stmt).first()
                
                # Then try to find by display name
                if not author:
                    stmt = select(User).where(User.display_name == author_name)
                    author = session.exec(stmt).first()
                
                # Create new user if not found
                if not author:
                    author = User(
                        id=uuid.uuid4().hex,
                        display_name=author_name,
                        religious_preference=prayer_data.get('religious_preference', 'unspecified')
                    )
                    session.add(author)
                    session.flush()  # Get the ID
                
                # Parse created_at if provided
                created_at = datetime.utcnow()
                if 'created_at' in prayer_data:
                    try:
                        created_at = datetime.fromisoformat(prayer_data['created_at'].replace('Z', '+00:00'))
                    except:
                        pass  # Use current time if parsing fails
                
                # Create prayer
                prayer = Prayer(
                    id=uuid.uuid4().hex,
                    author_id=author.id,
                    text=prayer_data['text'],
                    generated_prayer=prayer_data.get('generated_prayer'),
                    project_tag=prayer_data.get('project_tag'),
                    target_audience=prayer_data.get('target_audience', 'all'),
                    created_at=created_at
                )
                
                session.add(prayer)
                imported_count += 1
                
                if imported_count % 100 == 0:
                    print(f'   Imported {imported_count} prayers...')
                
            except Exception as e:
                print(f'‚ùå Error importing prayer {i+1}: {e}')
                error_count += 1
                continue
        
        # Commit all changes
        session.commit()
    
    print()
    print('‚úÖ Prayer import completed!')
    print(f'   Imported: {imported_count} prayers')
    if skipped_count > 0:
        print(f'   Skipped: {skipped_count} prayers (missing data)')
    if error_count > 0:
        print(f'   Errors: {error_count} prayers (failed to import)')

except Exception as e:
    print(f'‚ùå Error importing prayers: {e}')
    sys.exit(1)
"
}

cmd_import_community() {
    local file_path="${1:-}"
    shift || true  # Remove file_path from arguments
    
    if [ -z "$file_path" ]; then
        error "File path required"
        echo "Usage: thywill import community <zip_file> [options]"
        echo ""
        echo "Options:"
        echo "  --dry-run      Preview import without making changes"
        echo "  --overwrite    Overwrite existing records"
        echo ""
        echo "Examples:"
        echo "  thywill import community community_export_2024-12-06.zip"
        echo "  thywill import community export.zip --dry-run"
        echo "  thywill import community export.zip --overwrite"
        exit 1
    fi
    
    if [ ! -f "$file_path" ]; then
        error "File not found: $file_path"
        exit 1
    fi
    
    header "Importing Community Data from $file_path"
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ] && [ ! -f "thywill.db" ]; then
        error "Must run from ThyWill project directory"
        echo "Database or models.py not found"
        exit 1
    fi
    
    # Check if import script exists
    if [ ! -f "import_community_data.py" ]; then
        error "Community import script not found: import_community_data.py"
        echo "Please ensure the import script is in the project directory"
        exit 1
    fi
    
    log "Running community data import..."
    
    # Execute Python import script with all remaining arguments
    python3 import_community_data.py "$file_path" "$@"
}

# Database commands
cmd_db() {
    local subcommand="${1:-}"
    shift || true
    
    case "$subcommand" in
        init)
            cmd_db_init "$@"
            ;;
        *)
            error "Unknown database subcommand: $subcommand"
            echo "Available subcommands: init"
            echo "Usage: thywill db <subcommand> [args]"
            echo ""
            echo "Examples:"
            echo "  thywill db init        # Initialize database tables (first time only)"
            exit 1
            ;;
    esac
}

cmd_db_init() {
    header "Database Initialization"
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ]; then
        error "models.py not found in current directory"
        echo "Please run this command from your ThyWill project directory"
        exit 1
    fi
    
    # Check if create_database.py exists
    if [ ! -f "create_database.py" ]; then
        error "create_database.py script not found"
        echo "Please ensure the database creation script is in the project directory"
        exit 1
    fi
    
    log "Running database initialization script..."
    echo ""
    
    # Execute the standalone database creation script
    python3 create_database.py
    
    if [ $? -eq 0 ]; then
        echo ""
        success "Database initialization completed!"
        echo ""
        echo "Next steps:"
        echo "  thywill start          # Start development server"
        echo "  thywill admin token    # Create first admin account"
    else
        echo ""
        error "Database initialization failed"
        echo "Check the error messages above for details"
        exit 1
    fi
}

# Utility commands
cmd_setup() {
    header "ThyWill Complete Ubuntu Setup"
    
    log "This will install all required packages and set up the development environment"
    echo ""
    warning "This command will:"
    echo "  1. Update apt packages"
    echo "  2. Install Python 3, pip, venv, nginx, sqlite3"
    echo "  3. Create virtual environment"
    echo "  4. Install Python dependencies"
    echo "  5. Set up database"
    echo "  6. Configure systemd service"
    echo "  7. Set up nginx (optional)"
    echo "  8. Initialize backup system"
    echo ""
    
    read -p "Continue with setup? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        warning "Setup cancelled"
        exit 0
    fi
    
    # Step 1: Update system packages
    header "Step 1: Updating system packages"
    sudo apt update
    
    # Step 2: Install system dependencies
    header "Step 2: Installing system dependencies"
    sudo apt install -y python3 python3-pip python3-venv python3-dev \
                        sqlite3 nginx curl git build-essential \
                        software-properties-common
    
    # Step 3: Create Python virtual environment
    header "Step 3: Setting up Python virtual environment"
    if [ ! -d "venv" ]; then
        log "Creating virtual environment..."
        python3 -m venv venv
    else
        log "Virtual environment already exists"
    fi
    
    # Step 4: Install Python dependencies
    header "Step 4: Installing Python dependencies"
    source venv/bin/activate
    pip install --upgrade pip
    pip install -r requirements.txt
    
    # Step 5: Initialize database
    header "Step 5: Setting up database"
    if [ ! -f "thywill.db" ]; then
        log "Creating database..."
        python -c "
from models import create_db_and_tables
create_db_and_tables()
print('Database created successfully')
"
    else
        log "Database already exists"
    fi
    
    # Step 6: Set up production user (if we're setting up for production)
    if [ "$USER" != "thywill" ] && [ "$PWD" != "/home/thywill/thywill" ]; then
        header "Step 6: Development setup complete!"
        success "Development environment ready!"
        echo ""
        echo "Next steps:"
        echo "  thywill start          # Start development server"
        echo "  thywill install        # Install CLI globally"
        echo ""
        echo "For production setup on this server:"
        echo "  sudo adduser thywill"
        echo "  sudo cp -r . /home/thywill/thywill"
        echo "  sudo chown -R thywill:thywill /home/thywill/thywill"
        echo "  thywill setup-production"
    else
        header "Step 6: Setting up production environment"
        cmd_setup_production
    fi
}

cmd_setup_production() {
    header "Production Environment Setup"
    
    # Create required directories
    log "Creating directories..."
    sudo mkdir -p /home/thywill/backups/{hourly,daily,weekly}
    sudo mkdir -p /home/thywill/deploy_logs
    sudo mkdir -p /home/thywill/logs
    sudo chown -R thywill:thywill /home/thywill/
    
    # Set up systemd service
    log "Setting up systemd service..."
    sudo cp deployment/thywill.service /etc/systemd/system/
    sudo systemctl daemon-reload
    sudo systemctl enable thywill
    
    # Prompt for nginx setup
    echo ""
    log "Nginx configuration options:"
    echo "1) Domain-based (recommended for production)"
    echo "2) IP-only access"
    echo "3) Skip nginx setup"
    read -p "Choose option (1-3): " nginx_choice
    
    case $nginx_choice in
        1)
            read -p "Enter your domain name: " domain_name
            if [ -n "$domain_name" ]; then
                sed "s/your-domain.com/$domain_name/g" deployment/nginx-domain.conf > /tmp/thywill-nginx.conf
                sudo cp /tmp/thywill-nginx.conf /etc/nginx/sites-available/thywill
                sudo ln -sf /etc/nginx/sites-available/thywill /etc/nginx/sites-enabled/
                sudo nginx -t && sudo systemctl reload nginx
                success "Nginx configured for domain: $domain_name"
            fi
            ;;
        2)
            sudo cp deployment/nginx-ip-only.conf /etc/nginx/sites-available/thywill
            sudo ln -sf /etc/nginx/sites-available/thywill /etc/nginx/sites-enabled/
            sudo nginx -t && sudo systemctl reload nginx
            success "Nginx configured for IP access"
            ;;
        3)
            log "Skipping nginx setup"
            ;;
    esac
    
    # Set up environment file
    if [ ! -f ".env" ]; then
        log "Creating environment file..."
        cp deployment/sample.env .env
        warning "Please edit .env file with your actual values"
    fi
    
    # Set up automated backups
    log "Setting up automated backups..."
    if ! crontab -l 2>/dev/null | grep -q "thywill"; then
        log "Adding crontab entries..."
        (crontab -l 2>/dev/null; cat deployment/crontab_backups.txt) | crontab -
        success "Automated backups configured"
    else
        log "Backup crontab already configured"
    fi
    
    # Start service
    log "Starting ThyWill service..."
    sudo systemctl start thywill
    
    # Final verification
    sleep 3
    if systemctl is-active --quiet thywill; then
        success "ThyWill service is running!"
        if curl -s http://127.0.0.1:8000/health > /dev/null 2>&1; then
            success "Health check passed!"
        else
            warning "Service running but health check failed - check logs"
        fi
    else
        error "Service failed to start - check logs"
        echo "Run: journalctl -u thywill -n 20"
    fi
    
    echo ""
    success "Production setup complete!"
    echo ""
    echo "Service status: $(systemctl is-active thywill)"
    echo "View logs: thywill logs"
    echo "Check health: thywill health"
    echo "Create backup: thywill backup"
}

cmd_init() {
    header "Initializing ThyWill Deployment Environment"
    
    log "Creating required directories..."
    sudo mkdir -p /home/thywill/backups/{hourly,daily,weekly}
    sudo mkdir -p /home/thywill/deploy_logs
    sudo mkdir -p /home/thywill/logs
    
    if id "thywill" &>/dev/null; then
        sudo chown -R thywill:thywill /home/thywill/backups
        sudo chown -R thywill:thywill /home/thywill/deploy_logs
        sudo chown -R thywill:thywill /home/thywill/logs
        success "Directory ownership set to thywill user"
    else
        warning "User 'thywill' not found. Please set proper ownership manually."
    fi
    
    log "Making scripts executable..."
    chmod +x "$DEPLOYMENT_DIR"/*.sh
    chmod +x "$DEPLOYMENT_DIR"/*.py
    
    log "Setting up automated backups..."
    if [ -f "$DEPLOYMENT_DIR/crontab_backups.txt" ]; then
        echo ""
        warning "To complete setup, add these crontab entries:"
        echo "Run: crontab -e"
        echo "Then add the following lines:"
        echo ""
        cat "$DEPLOYMENT_DIR/crontab_backups.txt"
        echo ""
    fi
    
    success "ThyWill deployment environment initialized!"
    echo ""
    echo "Next steps:"
    echo "1. Set up crontab entries for automated backups"
    echo "2. Test deployment: thywill deploy"
    echo "3. Test backup: thywill backup"
}

cmd_config() {
    header "Current Configuration"
    
    echo ""
    echo "Paths:"
    echo "  Application Directory: $APP_DIR"
    echo "  Backup Directory: $BACKUP_DIR"
    echo "  Deployment Scripts: $DEPLOYMENT_DIR"
    echo ""
    
    echo "Service Status:"
    if systemctl is-active --quiet thywill; then
        echo "  ThyWill Service: RUNNING"
    else
        echo "  ThyWill Service: STOPPED"
    fi
    
    echo ""
    echo "Available Scripts:"
    ls -la "$DEPLOYMENT_DIR"/*.sh "$DEPLOYMENT_DIR"/*.py 2>/dev/null | while read -r line; do
        echo "  $line"
    done
    
    echo ""
    echo "Backup Statistics:"
    if [ -d "$BACKUP_DIR" ]; then
        echo "  Hourly backups: $(find $BACKUP_DIR/hourly -name "*.db" 2>/dev/null | wc -l)"
        echo "  Daily backups: $(find $BACKUP_DIR/daily -name "*.db" 2>/dev/null | wc -l)"
        echo "  Weekly backups: $(find $BACKUP_DIR/weekly -name "*.db" 2>/dev/null | wc -l)"
        
        local total_size
        total_size=$(du -sh "$BACKUP_DIR" 2>/dev/null | cut -f1 || echo "Unknown")
        echo "  Total backup size: $total_size"
    else
        echo "  Backup directory not found"
    fi
}

cmd_install() {
    header "Installing ThyWill CLI Globally"
    
    local script_path="$SCRIPT_DIR/thywill"
    local install_path="/usr/local/bin/thywill"
    
    if [ ! -f "$script_path" ]; then
        error "ThyWill CLI script not found at: $script_path"
        exit 1
    fi
    
    log "Installing thywill to $install_path..."
    
    # Create the symlink
    if sudo ln -sf "$script_path" "$install_path"; then
        success "ThyWill CLI installed successfully!"
        echo ""
        echo "You can now use 'thywill' from anywhere (no more ./)"
        echo ""
        echo "Try it out:"
        echo "  thywill help"
        echo "  thywill status"
        echo "  thywill config"
    else
        error "Failed to install ThyWill CLI"
        exit 1
    fi
}

cmd_uninstall() {
    header "Uninstalling ThyWill CLI"
    
    local install_path="/usr/local/bin/thywill"
    
    if [ ! -L "$install_path" ] && [ ! -f "$install_path" ]; then
        warning "ThyWill CLI is not installed globally"
        echo "Use ./thywill to run from current directory"
        return 0
    fi
    
    log "Removing $install_path..."
    
    if sudo rm -f "$install_path"; then
        success "ThyWill CLI uninstalled successfully!"
        echo ""
        echo "You'll need to use './thywill' to run from the project directory"
    else
        error "Failed to uninstall ThyWill CLI"
        exit 1
    fi
}

# Main command dispatcher
main() {
    local command="${1:-help}"
    shift || true
    
    case "$command" in
        # Development commands
        start)
            cmd_start "$@"
            ;;
        
        # Deployment commands
        deploy)
            cmd_deploy "$@"
            ;;
        rollback)
            cmd_rollback "$@"
            ;;
        health)
            cmd_health "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        logs)
            cmd_logs "$@"
            ;;
        
        # Backup commands
        backup)
            cmd_backup "$@"
            ;;
        list)
            cmd_list "$@"
            ;;
        restore)
            cmd_restore "$@"
            ;;
        cleanup)
            cmd_cleanup "$@"
            ;;
        verify)
            cmd_verify "$@"
            ;;
        
        # Admin commands
        admin)
            cmd_admin "$@"
            ;;
        role)
            cmd_role "$@"
            ;;
        import)
            cmd_import "$@"
            ;;
        
        # Database commands
        db)
            cmd_db "$@"
            ;;
        
        # Utility commands
        setup)
            cmd_setup "$@"
            ;;
        init)
            cmd_init "$@"
            ;;
        install)
            cmd_install "$@"
            ;;
        uninstall)
            cmd_uninstall "$@"
            ;;
        config)
            cmd_config "$@"
            ;;
        help|--help|-h)
            show_help
            ;;
        version|--version|-v)
            show_version
            ;;
        
        *)
            error "Unknown command: $command"
            echo ""
            echo "Use 'thywill help' to see available commands"
            exit 1
            ;;
    esac
}

# Execute main function with all arguments
main "$@"