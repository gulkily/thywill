#!/bin/bash

# ThyWill CLI - Git-style command-line utility for deployment and backup operations
# Usage: ./thywill <command> [options]

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
APP_DIR="/home/thywill/thywill"
DEPLOYMENT_DIR="$APP_DIR/deployment"
BACKUP_DIR="/home/thywill/backups"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Logging functions
log() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

header() {
    echo -e "${BOLD}${CYAN}$1${NC}"
}

# Virtual environment activation function
ensure_venv() {
    # Check if we're already in a virtual environment
    if [ -n "${VIRTUAL_ENV:-}" ]; then
        return 0
    fi
    
    # Check if virtual environment exists
    if [ -d "venv" ]; then
        log "Activating virtual environment..."
        source venv/bin/activate
        return 0
    elif [ -d "$APP_DIR/venv" ]; then
        log "Activating virtual environment from $APP_DIR..."
        source "$APP_DIR/venv/bin/activate"
        return 0
    else
        warning "Virtual environment not found"
        echo "Please run: python3 -m venv venv && source venv/bin/activate && pip install -r requirements.txt"
        return 1
    fi
}

# Python execution wrapper that ensures venv is activated
run_python() {
    if ! ensure_venv; then
        error "Virtual environment activation failed"
        echo "Please ensure you have a working virtual environment:"
        echo "  python3 -m venv venv"
        echo "  source venv/bin/activate"
        echo "  pip install -r requirements.txt"
        exit 1
    fi
    PRODUCTION_MODE=1 python3 "$@"
}

# Help functions
show_help() {
    header "ThyWill CLI - Deployment and Backup Management"
    echo ""
    echo "USAGE:"
    echo "    thywill <command> [options]"
    echo ""
    echo "COMMANDS:"
    echo ""
    header "  Development Commands:"
    echo "    start [port]        Start local development server (default: 8000)"
    echo ""
    header "  Deployment Commands:"
    echo "    deploy              Deploy application with automatic rollback"
    echo "    rollback [backup]   Rollback to previous version or specific backup"
    echo "    health              Check application health status"
    echo "    status              Show deployment and service status"
    echo "    logs [lines]        Show application logs (default: 50 lines)"
    echo ""
    header "  Backup Commands:"
    echo "    backup              Create database backup"
    echo "    list                List all available backups"
    echo "    restore <file>      Restore from specific backup file"
    echo "    cleanup             Clean up old backups"
    echo "    verify <file>       Verify backup integrity"
    echo ""
    header "  Admin Commands:"
    echo "    admin grant <name>      Grant admin role to user (by display name or ID)"
    echo "    admin revoke <name>     Revoke admin role from user"
    echo "    admin list              List all admin users"
    echo "    admin token [hours]     Create admin invite token"
    echo "    role list               List all available roles"
    echo "    role grant <user> <role> Grant specific role to user"
    echo "    role revoke <user> <role> Revoke specific role from user"
    echo "    import prayers <file>   Import prayers from JSON file"
    echo "    import community <file> Import community data from ZIP export"
    echo "    import text-archives    Import data from text_archives/ directory"
    echo "    validate-archives       Check archive completeness and integrity"
    echo "    test-recovery          Simulate complete database recovery"
    echo "    full-recovery          Perform complete database reconstruction"
    echo "    repair-archives        Fix archive inconsistencies"
    echo "    heal-archives          Create missing archive files for existing prayers and users"
    echo "    sync-archives          Complete archive synchronization (safe post-deploy)"
    echo "    recovery-report        Generate recovery capability report"
    echo ""
    header "  Database Commands:"
    echo "    db init             Initialize database tables (first time only)"
    echo "    migrate             Run database migrations (legacy)"
    echo "    migrate new         Run enhanced schema-only migrations"
    echo "    migrate status      Show migration status and pending migrations"
    echo "    migrate rollback    Rollback last migration"
    echo ""
    header "  Utility Commands:"
    echo "    setup               Complete development environment setup"
    echo "    init                Initialize deployment environment"
    echo "    install             Install thywill globally (no more ./)"
    echo "    uninstall           Remove global installation"
    echo "    config              Show current configuration"
    echo "    sqlite              Open SQLite3 with helpful flags and table listing"
    echo "    help                Show this help message"
    echo "    version             Show version information"
    echo ""
    echo "EXAMPLES:"
    echo "    thywill db init                                   # Initialize database (first time)"
    echo "    thywill setup                                     # Complete Ubuntu setup"
    echo "    thywill start                                     # Start dev server on port 8000"
    echo "    thywill admin grant \"John Smith\"                # Grant admin role"
    echo "    thywill role grant \"Jane Doe\" moderator         # Grant moderator role"
    echo "    thywill admin token 24                            # Create 24-hour admin token"
    echo "    thywill import prayers backup.json               # Import prayer data"
    echo "    thywill import community export.zip              # Import community export"
    echo "    thywill import text-archives --dry-run           # Preview text archive import"
    echo "    thywill import text-archives                     # Import from text_archives/"
    echo "    thywill validate-archives                        # Check archive integrity"
    echo "    thywill test-recovery                            # Simulate complete recovery"
    echo "    thywill full-recovery                            # Complete database reconstruction"
    echo "    thywill heal-archives                            # Create missing archive files for prayers and users"
    echo "    thywill sync-archives                            # Complete post-deploy sync"
    echo "    thywill recovery-report                          # Generate recovery report"
    echo "    thywill sqlite                                    # Open SQLite3 CLI with database"
    echo "    thywill deploy                                    # Safe deployment"
    echo "    thywill backup                                    # Create database backup"
    echo "    thywill rollback                                  # Rollback to previous"
    echo "    thywill health                                    # Check app health"
    echo ""
    echo "For more information, see: deployment/DEPLOYMENT_GUIDE.md"
}

show_version() {
    echo "ThyWill CLI v1.0.0"
    echo "Deployment and Backup Management Utility"
    echo "Built for ThyWill Prayer Application"
}

# Development commands
cmd_start() {
    local port="${1:-8000}"
    local host="${2:-127.0.0.1}"
    
    header "Starting Development Server"
    
    # Check if we're in the right directory
    if [ ! -f "app.py" ]; then
        error "app.py not found in current directory"
        echo "Please run this command from your ThyWill project directory"
        exit 1
    fi
    
    # Check if virtual environment exists
    if [ ! -d "venv" ]; then
        warning "Virtual environment not found. Creating one..."
        python3 -m venv venv
        source venv/bin/activate
        pip install -r requirements.txt
    else
        ensure_venv
    fi
    
    # Check if uvicorn is installed
    if ! python -c "import uvicorn" 2>/dev/null; then
        log "Installing uvicorn..."
        pip install uvicorn
    fi
    
    log "Starting development server on http://$host:$port"
    log "Press Ctrl+C to stop the server"
    echo ""
    
    # Start the development server
    exec uvicorn app:app --host "$host" --port "$port" --reload
}

# Deployment commands
cmd_deploy() {
    header "Starting Safe Deployment"
    
    if [ ! -f "$DEPLOYMENT_DIR/deploy.sh" ]; then
        error "Deployment script not found at $DEPLOYMENT_DIR/deploy.sh"
        exit 1
    fi
    
    log "Running deployment with automatic rollback..."
    cd "$SCRIPT_DIR"
    exec "$DEPLOYMENT_DIR/deploy.sh"
}

cmd_rollback() {
    local backup_file="${1:-}"
    
    header "Rolling Back Deployment"
    
    if [ -n "$backup_file" ]; then
        log "Rolling back to specific backup: $backup_file"
        "$DEPLOYMENT_DIR/backup_management.sh" restore "$backup_file"
    else
        log "Rolling back to most recent backup..."
        
        # Find most recent backup
        local latest_backup
        latest_backup=$(find "$BACKUP_DIR" -name "thywill_*.db" -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -d' ' -f2-)
        
        if [ -z "$latest_backup" ]; then
            error "No backups found for rollback"
            exit 1
        fi
        
        log "Found latest backup: $latest_backup"
        "$DEPLOYMENT_DIR/backup_management.sh" restore "$latest_backup"
    fi
}

cmd_health() {
    header "Application Health Check"
    
    log "Checking service status..."
    if systemctl is-active --quiet thywill; then
        success "ThyWill service is running"
    else
        error "ThyWill service is not running"
        echo "Run: sudo systemctl start thywill"
        exit 1
    fi
    
    log "Checking health endpoint..."
    if curl -f -s http://127.0.0.1:8000/health > /dev/null 2>&1; then
        success "Health endpoint responding"
        echo ""
        echo "Health Details:"
        curl -s http://127.0.0.1:8000/health | python3 -m json.tool 2>/dev/null || curl -s http://127.0.0.1:8000/health
    else
        error "Health endpoint not responding"
        warning "Application may be starting up or experiencing issues"
        cmd_logs 20
        exit 1
    fi
}

cmd_status() {
    header "System Status"
    
    echo ""
    log "Service Status:"
    systemctl status thywill --no-pager -l || true
    
    echo ""
    log "Recent Deployments:"
    if [ -d "/home/thywill/deploy_logs" ]; then
        ls -la /home/thywill/deploy_logs/ | tail -5 || echo "No deployment logs found"
    else
        echo "No deployment logs directory found"
    fi
    
    echo ""
    log "Backup Status:"
    if [ -d "$BACKUP_DIR" ]; then
        echo "Daily backups: $(find $BACKUP_DIR/daily -name "*.db" 2>/dev/null | wc -l) files"
        echo "Weekly backups: $(find $BACKUP_DIR/weekly -name "*.db" 2>/dev/null | wc -l) files"
        echo "Latest backup: $(find $BACKUP_DIR -name "thywill_*.db" -type f -printf '%T@ %p\n' 2>/dev/null | sort -n | tail -1 | cut -d' ' -f2- | xargs basename 2>/dev/null || echo 'None found')"
    else
        warning "Backup directory not found"
    fi
    
    echo ""
    log "Disk Usage:"
    df -h "$BACKUP_DIR" 2>/dev/null || df -h /home/thywill/ 2>/dev/null || df -h /home/
}

cmd_logs() {
    local lines="${1:-50}"
    
    header "Application Logs (last $lines lines)"
    
    if command -v journalctl >/dev/null 2>&1; then
        journalctl -u thywill -n "$lines" --no-pager
    else
        error "journalctl not available. Check system logs manually."
        exit 1
    fi
}

# Backup commands
cmd_backup() {
    header "Creating Database Backup"
    "$DEPLOYMENT_DIR/backup_management.sh" daily
}

cmd_list() {
    header "Available Backups"
    "$DEPLOYMENT_DIR/backup_management.sh" list
}

cmd_restore() {
    local backup_file="${1:-}"
    
    if [ -z "$backup_file" ]; then
        error "Backup file path required"
        echo "Usage: thywill restore <backup_file>"
        echo "Use 'thywill list' to see available backups"
        exit 1
    fi
    
    header "Restoring from Backup"
    "$DEPLOYMENT_DIR/backup_management.sh" restore "$backup_file"
}

cmd_cleanup() {
    header "Cleaning Up Old Backups"
    "$DEPLOYMENT_DIR/backup_management.sh" cleanup
}

cmd_verify() {
    local backup_file="${1:-}"
    
    if [ -z "$backup_file" ]; then
        error "Backup file path required"
        echo "Usage: thywill verify <backup_file>"
        exit 1
    fi
    
    header "Verifying Backup Integrity"
    
    if [ ! -f "$backup_file" ]; then
        error "Backup file not found: $backup_file"
        exit 1
    fi
    
    log "Checking file integrity..."
    if [ -f "${backup_file}.sha256" ]; then
        if sha256sum -c "${backup_file}.sha256" > /dev/null 2>&1; then
            success "Checksum verification passed"
        else
            error "Checksum verification failed"
            exit 1
        fi
    else
        warning "No checksum file found, skipping checksum verification"
    fi
    
    log "Checking database integrity..."
    if sqlite3 "$backup_file" "PRAGMA integrity_check;" | grep -q "ok"; then
        success "Database integrity check passed"
    else
        error "Database integrity check failed"
        exit 1
    fi
    
    success "Backup verification completed successfully"
}

# Admin commands
cmd_admin() {
    local subcommand="${1:-}"
    shift || true
    
    case "$subcommand" in
        grant)
            cmd_admin_grant "$@"
            ;;
        revoke)
            cmd_admin_revoke "$@"
            ;;
        list)
            cmd_admin_list "$@"
            ;;
        token)
            cmd_admin_token "$@"
            ;;
        *)
            error "Unknown admin subcommand: $subcommand"
            echo "Available subcommands: grant, revoke, list, token"
            echo "Usage: thywill admin <subcommand> [args]"
            exit 1
            ;;
    esac
}

cmd_admin_grant() {
    local user_identifier="${1:-}"
    
    if [ -z "$user_identifier" ]; then
        error "User identifier required"
        echo "Usage: thywill admin grant <display_name_or_user_id>"
        echo "Examples:"
        echo "  thywill admin grant \"John Smith\""
        echo "  thywill admin grant abc123def456"
        exit 1
    fi
    
    header "Granting Admin Rights"
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ] && [ ! -f "thywill.db" ]; then
        error "Must run from ThyWill project directory"
        echo "Database or models.py not found"
        exit 1
    fi
    
    log "Looking up user: $user_identifier"
    
    # Run Python script to grant admin role
    run_python -c "
import sys
sys.path.append('.')
from sqlmodel import Session, select
from models import engine, User, Role, UserRole
from datetime import datetime

user_identifier = '$user_identifier'

def find_user(session, identifier):
    # First try exact ID match
    stmt = select(User).where(User.id == identifier)
    user = session.exec(stmt).first()
    
    if not user:
        # Try exact display_name match
        stmt = select(User).where(User.display_name == identifier)
        user = session.exec(stmt).first()
    
    if not user:
        # Try partial display_name match
        stmt = select(User).where(User.display_name.contains(identifier))
        users = list(session.exec(stmt))
        
        if not users:
            print(f'‚ùå No user found matching: {identifier}')
            print('   Available users:')
            # Show first 10 users as examples
            all_users = list(session.exec(select(User).limit(10)))
            for u in all_users:
                print(f'   - \"{u.display_name}\" (ID: {u.id[:8]}...)')
            if len(all_users) == 10:
                print('   ... (showing first 10 users)')
            return None
        elif len(users) > 1:
            print(f'‚ùå Multiple users found matching: {identifier}')
            print('   Be more specific. Found:')
            for u in users:
                print(f'   - \"{u.display_name}\" (ID: {u.id[:8]}...)')
            return None
        else:
            return users[0]
    
    return user

try:
    with Session(engine) as session:
        user = find_user(session, user_identifier)
        if not user:
            sys.exit(1)
        
        # Get admin role
        stmt = select(Role).where(Role.name == 'admin')
        admin_role = session.exec(stmt).first()
        
        if not admin_role:
            print('‚ùå Admin role not found. Run migration first: python migrate_to_roles.py')
            sys.exit(1)
        
        # Check if user already has admin role
        if user.has_role('admin', session):
            print(f'‚ÑπÔ∏è  User \"{user.display_name}\" already has admin role')
            sys.exit(0)
        
        # Check for backward compatibility (old system)
        if user.id == 'admin':
            print(f'‚ÑπÔ∏è  User \"{user.display_name}\" already has admin rights (old system)')
            print('   Run migration to convert to role-based system: python migrate_to_roles.py')
            sys.exit(0)
        
        # Grant admin role
        user_role = UserRole(
            user_id=user.id,
            role_id=admin_role.id,
            granted_by=None,  # CLI granted
            granted_at=datetime.utcnow()
        )
        session.add(user_role)
        session.commit()
        
        print(f'‚úÖ Admin role granted to: \"{user.display_name}\"')
        print(f'   User ID: {user.id[:8]}...')
        print('   ‚ú® Using new role-based permission system')

except Exception as e:
    print(f'‚ùå Error granting admin role: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
"
}

cmd_admin_revoke() {
    local user_identifier="${1:-}"
    
    if [ -z "$user_identifier" ]; then
        error "User identifier required"
        echo "Usage: thywill admin revoke <display_name_or_user_id>"
        echo "Examples:"
        echo "  thywill admin revoke \"John Smith\""
        echo "  thywill admin revoke abc123def456"
        exit 1
    fi
    
    header "Revoking Admin Role"
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ] && [ ! -f "thywill.db" ]; then
        error "Must run from ThyWill project directory"
        exit 1
    fi
    
    log "Looking up user: $user_identifier"
    
    run_python -c "
import sys
sys.path.append('.')
from sqlmodel import Session, select
from models import engine, User, Role, UserRole

user_identifier = '$user_identifier'

def find_user(session, identifier):
    # First try exact ID match
    stmt = select(User).where(User.id == identifier)
    user = session.exec(stmt).first()
    
    if not user:
        # Try exact display_name match
        stmt = select(User).where(User.display_name == identifier)
        user = session.exec(stmt).first()
    
    if not user:
        # Try partial display_name match
        stmt = select(User).where(User.display_name.contains(identifier))
        users = list(session.exec(stmt))
        
        if not users:
            print(f'‚ùå No user found matching: {identifier}')
            return None
        elif len(users) > 1:
            print(f'‚ùå Multiple users found matching: {identifier}')
            print('   Be more specific. Found:')
            for u in users:
                print(f'   - \"{u.display_name}\" (ID: {u.id[:8]}...)')
            return None
        else:
            return users[0]
    
    return user

try:
    with Session(engine) as session:
        user = find_user(session, user_identifier)
        if not user:
            sys.exit(1)
        
        # Get admin role
        stmt = select(Role).where(Role.name == 'admin')
        admin_role = session.exec(stmt).first()
        
        if not admin_role:
            print('‚ùå Admin role not found. Run migration first: python migrate_to_roles.py')
            sys.exit(1)
        
        # Check if user has admin role
        if not user.has_role('admin', session):
            print(f'‚ÑπÔ∏è  User \"{user.display_name}\" does not have admin role')
            sys.exit(0)
        
        # Remove admin role
        stmt = select(UserRole).where(
            UserRole.user_id == user.id,
            UserRole.role_id == admin_role.id
        )
        user_roles = session.exec(stmt).all()
        
        for user_role in user_roles:
            session.delete(user_role)
        
        session.commit()
        
        print(f'‚úÖ Admin role revoked from: \"{user.display_name}\"')
        print(f'   User ID: {user.id[:8]}...')
        print('   ‚ú® Using new role-based permission system')

except Exception as e:
    print(f'‚ùå Error revoking admin role: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
"
}

cmd_admin_list() {
    header "Admin Users"
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ] && [ ! -f "thywill.db" ]; then
        error "Must run from ThyWill project directory"
        exit 1
    fi
    
    run_python -c "
import sys
sys.path.append('.')
from sqlmodel import Session, select, func
from models import engine, User, Role, UserRole

try:
    with Session(engine) as session:
        # Try role-based system first
        try:
            stmt = select(User).join(UserRole, User.id == UserRole.user_id).join(Role, UserRole.role_id == Role.id).where(
                Role.name == 'admin',
                (UserRole.expires_at.is_(None)) | (UserRole.expires_at > func.datetime('now'))
            )
            admin_users = session.exec(stmt).all()
            
            if admin_users:
                print('üëë Admin Users (Role-based system):')
                for user in admin_users:
                    roles = user.get_roles(session)
                    role_names = [r.name for r in roles]
                    print(f'   ‚Ä¢ {user.display_name}')
                    print(f'     ID: {user.id[:8]}...')
                    print(f'     Roles: {\", \".join(role_names)}')
                    print(f'     Created: {user.created_at}')
                    print()
            else:
                print('‚ÑπÔ∏è  No admin users found in role-based system')
        except Exception as role_error:
            print('‚ö†Ô∏è  Role-based system not available (tables not created yet)')
            
        # Check old system for backward compatibility
        stmt = select(User).where(User.id == 'admin')
        old_admin = session.exec(stmt).first()
        
        if old_admin:
            print('üëë Admin User (Old system - needs migration):')
            print(f'   ‚Ä¢ {old_admin.display_name}')
            print(f'     ID: admin (legacy)')
            print(f'     Created: {old_admin.created_at}')
            print()
            print('üí° Run \"python migrate_to_roles.py\" to upgrade to role-based system')
        
        if not admin_users and not old_admin:
            print('‚ÑπÔ∏è  No admin users found')
            print('   Use \"thywill admin token\" to create an admin invite')

except Exception as e:
    print(f'‚ùå Error listing admins: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
"
}

cmd_admin_token() {
    local hours="${1:-12}"
    
    header "Creating Admin Invite Token"
    
    # Validate hours
    if ! [[ "$hours" =~ ^[0-9]+$ ]] || [ "$hours" -le 0 ]; then
        error "Hours must be a positive number"
        echo "Usage: thywill admin token [hours]"
        exit 1
    fi
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ] && [ ! -f "thywill.db" ]; then
        error "Must run from ThyWill project directory"
        exit 1
    fi
    
    # Call the standalone Python script to create admin token
    if ! run_python create_admin_token.py --hours "$hours"; then
        error "Failed to create admin token"
        exit 1
    fi
}

cmd_role() {
    local subcommand="${1:-}"
    shift || true
    
    case "$subcommand" in
        list)
            cmd_role_list "$@"
            ;;
        grant)
            cmd_role_grant "$@"
            ;;
        revoke)
            cmd_role_revoke "$@"
            ;;
        *)
            error "Unknown role subcommand: $subcommand"
            echo "Available subcommands: list, grant, revoke"
            echo "Usage: thywill role <subcommand> [args]"
            echo ""
            echo "Examples:"
            echo "  thywill role list"
            echo "  thywill role grant \"John Smith\" moderator"
            echo "  thywill role revoke \"John Smith\" moderator"
            exit 1
            ;;
    esac
}

cmd_role_list() {
    header "Available Roles"
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ] && [ ! -f "thywill.db" ]; then
        error "Must run from ThyWill project directory"
        exit 1
    fi
    
    run_python -c "
import sys
sys.path.append('.')
from sqlmodel import Session, select
from models import engine, Role, UserRole, User
import json

try:
    with Session(engine) as session:
        # Get all roles
        stmt = select(Role)
        roles = session.exec(stmt).all()
        
        if not roles:
            print('‚ÑπÔ∏è  No roles found. Run migration first: python migrate_to_roles.py')
            sys.exit(0)
        
        for role in roles:
            try:
                permissions = json.loads(role.permissions)
            except:
                permissions = []
            
            # Count users with this role
            stmt = select(UserRole).where(UserRole.role_id == role.id)
            user_count = len(list(session.exec(stmt)))
            
            system_marker = ' üîí' if role.is_system_role else ''
            
            print(f'üìã {role.name}{system_marker}')
            print(f'   Description: {role.description or \"No description\"}')
            print(f'   Users: {user_count}')
            print(f'   Permissions: {len(permissions)}')
            if permissions:
                perm_preview = ', '.join(permissions[:3])
                if len(permissions) > 3:
                    perm_preview += f' ... (+{len(permissions)-3} more)'
                print(f'              {perm_preview}')
            print()

except Exception as e:
    print(f'‚ùå Error listing roles: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
"
}

cmd_role_grant() {
    local user_identifier="${1:-}"
    local role_name="${2:-}"
    
    if [ -z "$user_identifier" ] || [ -z "$role_name" ]; then
        error "User and role required"
        echo "Usage: thywill role grant <user> <role>"
        echo "Examples:"
        echo "  thywill role grant \"John Smith\" moderator"
        echo "  thywill role grant abc123def456 user"
        exit 1
    fi
    
    header "Granting Role: $role_name"
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ] && [ ! -f "thywill.db" ]; then
        error "Must run from ThyWill project directory"
        exit 1
    fi
    
    log "Looking up user: $user_identifier"
    log "Role to grant: $role_name"
    
    run_python -c "
import sys
sys.path.append('.')
from sqlmodel import Session, select
from models import engine, User, Role, UserRole
from datetime import datetime

user_identifier = '$user_identifier'
role_name = '$role_name'

def find_user(session, identifier):
    # User lookup logic (same as admin commands)
    stmt = select(User).where(User.id == identifier)
    user = session.exec(stmt).first()
    
    if not user:
        stmt = select(User).where(User.display_name == identifier)
        user = session.exec(stmt).first()
    
    if not user:
        stmt = select(User).where(User.display_name.contains(identifier))
        users = list(session.exec(stmt))
        
        if not users:
            print(f'‚ùå No user found matching: {identifier}')
            return None
        elif len(users) > 1:
            print(f'‚ùå Multiple users found matching: {identifier}')
            for u in users:
                print(f'   - \"{u.display_name}\" (ID: {u.id[:8]}...)')
            return None
        else:
            return users[0]
    
    return user

try:
    with Session(engine) as session:
        user = find_user(session, user_identifier)
        if not user:
            sys.exit(1)
        
        # Get role
        stmt = select(Role).where(Role.name == role_name)
        role = session.exec(stmt).first()
        
        if not role:
            print(f'‚ùå Role \"{role_name}\" not found')
            print('   Available roles:')
            stmt = select(Role)
            all_roles = session.exec(stmt).all()
            for r in all_roles:
                print(f'   - {r.name}')
            sys.exit(1)
        
        # Check if user already has this role
        if user.has_role(role_name, session):
            print(f'‚ÑπÔ∏è  User \"{user.display_name}\" already has role \"{role_name}\"')
            sys.exit(0)
        
        # Grant role
        user_role = UserRole(
            user_id=user.id,
            role_id=role.id,
            granted_by=None,  # CLI granted
            granted_at=datetime.utcnow()
        )
        session.add(user_role)
        session.commit()
        
        print(f'‚úÖ Role \"{role_name}\" granted to: \"{user.display_name}\"')
        print(f'   User ID: {user.id[:8]}...')

except Exception as e:
    print(f'‚ùå Error granting role: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
"
}

cmd_role_revoke() {
    local user_identifier="${1:-}"
    local role_name="${2:-}"
    
    if [ -z "$user_identifier" ] || [ -z "$role_name" ]; then
        error "User and role required"
        echo "Usage: thywill role revoke <user> <role>"
        echo "Examples:"
        echo "  thywill role revoke \"John Smith\" moderator"
        echo "  thywill role revoke abc123def456 user"
        exit 1
    fi
    
    header "Revoking Role: $role_name"
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ] && [ ! -f "thywill.db" ]; then
        error "Must run from ThyWill project directory"
        exit 1
    fi
    
    log "Looking up user: $user_identifier"
    log "Role to revoke: $role_name"
    
    run_python -c "
import sys
sys.path.append('.')
from sqlmodel import Session, select
from models import engine, User, Role, UserRole

user_identifier = '$user_identifier'
role_name = '$role_name'

def find_user(session, identifier):
    # User lookup logic (same as admin commands)
    stmt = select(User).where(User.id == identifier)
    user = session.exec(stmt).first()
    
    if not user:
        stmt = select(User).where(User.display_name == identifier)
        user = session.exec(stmt).first()
    
    if not user:
        stmt = select(User).where(User.display_name.contains(identifier))
        users = list(session.exec(stmt))
        
        if not users:
            print(f'‚ùå No user found matching: {identifier}')
            return None
        elif len(users) > 1:
            print(f'‚ùå Multiple users found matching: {identifier}')
            for u in users:
                print(f'   - \"{u.display_name}\" (ID: {u.id[:8]}...)')
            return None
        else:
            return users[0]
    
    return user

try:
    with Session(engine) as session:
        user = find_user(session, user_identifier)
        if not user:
            sys.exit(1)
        
        # Get role
        stmt = select(Role).where(Role.name == role_name)
        role = session.exec(stmt).first()
        
        if not role:
            print(f'‚ùå Role \"{role_name}\" not found')
            sys.exit(1)
        
        # Check if user has this role
        if not user.has_role(role_name, session):
            print(f'‚ÑπÔ∏è  User \"{user.display_name}\" does not have role \"{role_name}\"')
            sys.exit(0)
        
        # Revoke role
        stmt = select(UserRole).where(
            UserRole.user_id == user.id,
            UserRole.role_id == role.id
        )
        user_roles = session.exec(stmt).all()
        
        for user_role in user_roles:
            session.delete(user_role)
        
        session.commit()
        
        print(f'‚úÖ Role \"{role_name}\" revoked from: \"{user.display_name}\"')
        print(f'   User ID: {user.id[:8]}...')

except Exception as e:
    print(f'‚ùå Error revoking role: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
"
}

cmd_import() {
    local import_type="${1:-}"
    local file_path="${2:-}"
    
    case "$import_type" in
        prayers)
            cmd_import_prayers "$file_path"
            ;;
        text-archives)
            cmd_import_text_archives "${@:2}"
            ;;
        *)
            error "Unknown import type: $import_type"
            echo "Available import types: prayers, text-archives"
            echo "Usage: thywill import <type> <file> [options]"
            echo ""
            echo "Examples:"
            echo "  thywill import prayers backup.json"
            echo "  thywill import text-archives"
            echo "  thywill import text-archives --dry-run"
            exit 1
            ;;
    esac
}

cmd_import_prayers() {
    local file_path="${1:-}"
    
    if [ -z "$file_path" ]; then
        error "File path required"
        echo "Usage: thywill import prayers <json_file>"
        echo ""
        echo "Expected JSON format:"
        echo '['
        echo '  {'
        echo '    "text": "Prayer request text",'
        echo '    "generated_prayer": "Generated prayer response",'
        echo '    "author_name": "User Display Name",'
        echo '    "author_id": "existing_user_id (optional)",'
        echo '    "project_tag": "optional tag",'
        echo '    "target_audience": "all",'
        echo '    "created_at": "2023-12-01T10:00:00"'
        echo '  }'
        echo ']'
        exit 1
    fi
    
    if [ ! -f "$file_path" ]; then
        error "File not found: $file_path"
        exit 1
    fi
    
    header "Importing Prayers from $file_path"
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ] && [ ! -f "thywill.db" ]; then
        error "Must run from ThyWill project directory"
        exit 1
    fi
    
    log "Validating JSON file..."
    
    # Validate JSON first
    if ! run_python -c "import json; json.load(open('$file_path'))" 2>/dev/null; then
        error "Invalid JSON file"
        exit 1
    fi
    
    log "Importing prayers..."
    
    run_python -c "
import sys
sys.path.append('.')
import json
import uuid
from datetime import datetime
from sqlmodel import Session, select
from models import engine, User, Prayer

file_path = '$file_path'

try:
    with open(file_path, 'r') as f:
        prayers_data = json.load(f)
    
    if not isinstance(prayers_data, list):
        print('‚ùå JSON file must contain an array of prayer objects')
        sys.exit(1)
    
    imported_count = 0
    skipped_count = 0
    error_count = 0
    
    with Session(engine) as session:
        for i, prayer_data in enumerate(prayers_data):
            try:
                # Validate required fields
                if 'text' not in prayer_data:
                    print(f'‚ö†Ô∏è  Skipping prayer {i+1}: missing \"text\" field')
                    skipped_count += 1
                    continue
                
                # Find or create user by ID or display name
                author_id = prayer_data.get('author_id')
                author_name = prayer_data.get('author_name', 'Imported User')
                
                author = None
                
                # First try to find by existing ID
                if author_id:
                    stmt = select(User).where(User.id == author_id)
                    author = session.exec(stmt).first()
                
                # Then try to find by display name
                if not author:
                    stmt = select(User).where(User.display_name == author_name)
                    author = session.exec(stmt).first()
                
                # Create new user if not found
                if not author:
                    author = User(
                        id=uuid.uuid4().hex,
                        display_name=author_name,
                        religious_preference=prayer_data.get('religious_preference', 'unspecified')
                    )
                    session.add(author)
                    session.flush()  # Get the ID
                
                # Parse created_at if provided
                created_at = datetime.utcnow()
                if 'created_at' in prayer_data:
                    try:
                        created_at = datetime.fromisoformat(prayer_data['created_at'].replace('Z', '+00:00'))
                    except:
                        pass  # Use current time if parsing fails
                
                # Create prayer
                prayer = Prayer(
                    id=uuid.uuid4().hex,
                    author_id=author.id,
                    text=prayer_data['text'],
                    generated_prayer=prayer_data.get('generated_prayer'),
                    project_tag=prayer_data.get('project_tag'),
                    target_audience=prayer_data.get('target_audience', 'all'),
                    created_at=created_at
                )
                
                session.add(prayer)
                imported_count += 1
                
                if imported_count % 100 == 0:
                    print(f'   Imported {imported_count} prayers...')
                
            except Exception as e:
                print(f'‚ùå Error importing prayer {i+1}: {e}')
                error_count += 1
                continue
        
        # Commit all changes
        session.commit()
    
    print()
    print('‚úÖ Prayer import completed!')
    print(f'   Imported: {imported_count} prayers')
    if skipped_count > 0:
        print(f'   Skipped: {skipped_count} prayers (missing data)')
    if error_count > 0:
        print(f'   Errors: {error_count} prayers (failed to import)')

except Exception as e:
    print(f'‚ùå Error importing prayers: {e}')
    sys.exit(1)
"
}


cmd_import_text_archives() {
    header "Importing Text Archives"
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ] && [ ! -f "thywill.db" ]; then
        error "Must run from ThyWill project directory"
        echo "Database or models.py not found"
        exit 1
    fi
    
    # Check if import script exists
    if [ ! -f "import_text_archives.py" ]; then
        error "Text archives import script not found: import_text_archives.py"
        echo "Please ensure the import script is in the project directory"
        exit 1
    fi
    
    # Check if we have a ZIP file argument or text_archives directory
    if [ "$#" -gt 0 ] && [[ "$1" == *.zip ]]; then
        # ZIP file provided
        if [ ! -f "$1" ]; then
            error "ZIP file not found: $1"
            exit 1
        fi
        log "Importing data from ZIP file: $1"
    else
        # Check if text_archives directory exists
        if [ ! -d "text_archives" ]; then
            error "text_archives directory not found"
            echo "Please ensure text_archives/ directory exists in the project root"
            echo "Or provide a ZIP file: thywill import text-archives archive.zip"
            exit 1
        fi
        log "Importing data from text_archives/ directory..."
    fi
    
    # Execute Python import script with all arguments
    run_python import_text_archives.py "$@"
}

# Archive validation and recovery commands
cmd_validate_archives() {
    header "Archive Validation"
    
    # Check if we're in the right directory
    if [ ! -f "app.py" ]; then
        error "app.py not found in current directory"
        echo "Please run this command from your ThyWill project directory"
        exit 1
    fi
    
    if [ ! -d "text_archives" ]; then
        warning "text_archives/ directory not found"
        echo "Creating empty text_archives/ directory for validation..."
        mkdir -p text_archives
    fi
    
    log "Validating archive completeness and integrity..."
    
    # Execute Python validation script
    run_python -c "
import sys
sys.path.append('.')
from app_helpers.services.database_recovery import CompleteSystemRecovery

try:
    recovery = CompleteSystemRecovery('text_archives')
    print('üîç Validating archive structure...')
    recovery._validate_archive_structure()
    
    print('üìä Archive Structure Report:')
    print('=' * 50)
    
    # Check core directories
    core_dirs = ['prayers', 'users', 'activity']
    for dir_name in core_dirs:
        path = recovery.archive_dir / dir_name
        if path.exists():
            file_count = len(list(path.glob('*.txt')))
            print(f'‚úÖ {dir_name}/: {file_count} files')
        else:
            print(f'‚ùå {dir_name}/: missing')
    
    # Check new directories
    new_dirs = ['auth', 'roles', 'system']
    for dir_name in new_dirs:
        path = recovery.archive_dir / dir_name
        if path.exists():
            file_count = len(list(path.rglob('*.txt')))
            print(f'‚úÖ {dir_name}/: {file_count} files')
        else:
            print(f'‚ö†Ô∏è  {dir_name}/: not found (will use defaults)')
    
    print()
    print('üìã Validation complete!')
    print('üí° Use \"thywill test-recovery\" to simulate recovery')
    
except Exception as e:
    print(f'‚ùå Validation failed: {e}')
    sys.exit(1)
"
}

cmd_test_recovery() {
    header "Test Recovery (Dry Run)"
    
    # Check if we're in the right directory
    if [ ! -f "app.py" ]; then
        error "app.py not found in current directory"
        echo "Please run this command from your ThyWill project directory"
        exit 1
    fi
    
    if [ ! -d "text_archives" ]; then
        error "text_archives/ directory not found"
        echo "Please ensure text_archives/ directory exists in the project root"
        exit 1
    fi
    
    log "Simulating complete database recovery (dry run)..."
    warning "This is a simulation - no actual changes will be made"
    
    # Execute Python recovery script in dry run mode
    run_python -c "
import sys
sys.path.append('.')
from app_helpers.services.database_recovery import CompleteSystemRecovery

try:
    recovery = CompleteSystemRecovery('text_archives')
    result = recovery.perform_complete_recovery(dry_run=True)
    
    if result['success']:
        print('üéâ Recovery simulation completed successfully!')
        print()
        print('üìä Recovery Statistics:')
        print('=' * 50)
        stats = result['stats']
        for key, value in stats.items():
            if isinstance(value, int) and value > 0:
                print(f'{key.replace(\"_\", \" \").title()}: {value}')
        
        if stats.get('warnings'):
            print()
            print('‚ö†Ô∏è  Warnings:')
            for warning in stats['warnings']:
                print(f'  ‚Ä¢ {warning}')
        
        if stats.get('errors'):
            print()
            print('‚ùå Errors:')
            for error in stats['errors']:
                print(f'  ‚Ä¢ {error}')
        
        print()
        print('üí° Use \"thywill full-recovery\" to perform actual recovery')
    else:
        print(f'‚ùå Recovery simulation failed: {result.get(\"error\", \"Unknown error\")}')
        sys.exit(1)
        
except Exception as e:
    print(f'‚ùå Recovery simulation failed: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
"
}

cmd_full_recovery() {
    header "Complete Database Recovery"
    
    # Check if we're in the right directory
    if [ ! -f "app.py" ]; then
        error "app.py not found in current directory"
        echo "Please run this command from your ThyWill project directory"
        exit 1
    fi
    
    if [ ! -d "text_archives" ]; then
        error "text_archives/ directory not found"
        echo "Please ensure text_archives/ directory exists in the project root"
        exit 1
    fi
    
    # Safety confirmation
    echo ""
    warning "IMPORTANT: This will completely reconstruct the database from text archives"
    warning "Make sure you have a backup of your current database!"
    echo ""
    read -p "Are you sure you want to proceed? (type 'yes' to continue): " confirm
    
    if [ "$confirm" != "yes" ]; then
        echo "Recovery cancelled."
        exit 0
    fi
    
    log "Performing complete database recovery from text archives..."
    
    # Create backup first
    timestamp=$(date '+%Y%m%d_%H%M%S')
    backup_name="pre_recovery_${timestamp}.db"
    
    if [ -f "thywill.db" ]; then
        log "Creating backup: $backup_name"
        cp thywill.db "$backup_name"
        success "Backup created: $backup_name"
    fi
    
    # Execute Python recovery script
    run_python -c "
import sys
sys.path.append('.')
from app_helpers.services.database_recovery import CompleteSystemRecovery

try:
    recovery = CompleteSystemRecovery('text_archives')
    result = recovery.perform_complete_recovery(dry_run=False)
    
    if result['success']:
        print('üéâ Complete database recovery finished successfully!')
        print()
        print('üìä Recovery Results:')
        print('=' * 50)
        stats = result['stats']
        for key, value in stats.items():
            if isinstance(value, int) and value > 0:
                print(f'{key.replace(\"_\", \" \").title()}: {value}')
        
        if stats.get('warnings'):
            print()
            print('‚ö†Ô∏è  Warnings:')
            for warning in stats['warnings']:
                print(f'  ‚Ä¢ {warning}')
        
        if stats.get('errors'):
            print()
            print('‚ùå Errors:')
            for error in stats['errors']:
                print(f'  ‚Ä¢ {error}')
        
        print()
        print('‚úÖ Database reconstruction complete!')
        print('üí° Test your application to ensure everything is working correctly')
    else:
        print(f'‚ùå Recovery failed: {result.get(\"error\", \"Unknown error\")}')
        print(f'üí° Your backup is available at: ${backup_name}')
        sys.exit(1)
        
except Exception as e:
    print(f'‚ùå Recovery failed: {e}')
    print(f'üí° Your backup is available at: ${backup_name}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
"
}

cmd_repair_archives() {
    header "Archive Repair"
    
    # Check if we're in the right directory
    if [ ! -f "app.py" ]; then
        error "app.py not found in current directory"
        echo "Please run this command from your ThyWill project directory"
        exit 1
    fi
    
    log "Checking and repairing archive inconsistencies..."
    
    # Execute Python repair script
    run_python -c "
import sys
sys.path.append('.')
from app_helpers.services.text_archive_service import TextArchiveService

try:
    archive_service = TextArchiveService('text_archives')
    
    print('üîß Archive repair functionality')
    print('‚ö†Ô∏è  This feature is planned for future implementation')
    print()
    print('Current repair capabilities:')
    print('  ‚Ä¢ Use \"thywill validate-archives\" to check integrity')
    print('  ‚Ä¢ Use \"thywill test-recovery\" to identify issues')
    print('  ‚Ä¢ Manual archive file repair may be needed for now')
    
except Exception as e:
    print(f'‚ùå Repair check failed: {e}')
    sys.exit(1)
"
}

cmd_heal_archives() {
    header "Archive Healing (Prayers & Users)"
    
    # Check if we're in the right directory
    if [ ! -f "heal_prayer_archives.py" ]; then
        error "heal_prayer_archives.py not found in current directory"
        echo "Please run this command from your ThyWill project directory"
        exit 1
    fi
    
    
    log "Creating missing archive files for existing prayers and users..."
    
    # Execute the healing script with proper production mode handling
    run_python heal_prayer_archives.py
}

cmd_sync_archives() {
    header "Complete Archive Synchronization"
    
    # Check if we're in the right directory
    if [ ! -f "app.py" ]; then
        error "app.py not found in current directory"
        echo "Please run this command from your ThyWill project directory"
        exit 1
    fi
    
    log "Performing complete archive synchronization after deployment..."
    echo ""
    warning "This will run all necessary commands to synchronize archives with database"
    echo "Steps to be performed:"
    echo "  0. Check database initialization (if needed)"
    echo "  1. Validate current archive structure"
    echo "  2. Import any missing data from text archives"
    echo "  3. Create missing archive files for existing prayers"
    echo "  4. Generate final validation report"
    echo ""
    
    # Step 0: Check if database is initialized
    log "Step 0: Checking database initialization..."
    if [ -f "thywill.db" ]; then
        log "Database file exists"
    else
        warning "Database file not found - database may need initialization"
        echo ""
        read -p "Initialize database now? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            log "Initializing database..."
            if ! cmd_db_init; then
                error "Database initialization failed"
                exit 1
            fi
        else
            error "Database initialization required but skipped"
            echo "Please run: thywill db init"
            exit 1
        fi
    fi
    
    echo ""
    
    # Step 1: Validate archives
    log "Step 1: Validating archive structure..."
    if ! cmd_validate_archives; then
        error "Archive validation failed"
        exit 1
    fi
    
    echo ""
    
    # Step 2: Import text archives (dry run first)
    log "Step 2: Checking what needs to be imported..."
    if ! cmd_import_text_archives --dry-run; then
        error "Text archive import check failed"
        exit 1
    fi
    
    echo ""
    read -p "Continue with import? (y/N): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        log "Importing text archives..."
        if ! cmd_import_text_archives; then
            error "Text archive import failed"
            exit 1
        fi
    else
        log "Skipping text archive import"
    fi
    
    echo ""
    
    # Step 3: Heal missing archive files
    log "Step 3: Creating missing archive files..."
    if ! cmd_heal_archives; then
        error "Archive healing failed"
        exit 1
    fi
    
    echo ""
    
    # Step 4: Final validation
    log "Step 4: Final validation..."
    if ! cmd_validate_archives; then
        warning "Final validation showed issues - review output above"
    fi
    
    echo ""
    success "Archive synchronization completed!"
    echo ""
    echo "Summary:"
    echo "  ‚úÖ Database initialization checked"
    echo "  ‚úÖ Archive structure validated"
    echo "  ‚úÖ Text archives imported"
    echo "  ‚úÖ Missing archive files created"
    echo "  ‚úÖ Final validation performed"
    echo ""
    echo "üí° Your archives and database should now be synchronized"
    echo "üí° Run 'thywill recovery-report' to see complete recovery capability"
}

cmd_recovery_report() {
    header "Recovery Capability Report"
    
    # Check if we're in the right directory
    if [ ! -f "app.py" ]; then
        error "app.py not found in current directory"
        echo "Please run this command from your ThyWill project directory"
        exit 1
    fi
    
    log "Generating recovery capability report..."
    
    # Execute Python report script
    run_python -c "
import sys
from pathlib import Path
sys.path.append('.')
from app_helpers.services.database_recovery import CompleteSystemRecovery

try:
    recovery = CompleteSystemRecovery('text_archives')
    archive_dir = recovery.archive_dir
    
    print('üìä Recovery Capability Report')
    print('=' * 60)
    print(f'Archive Directory: {archive_dir.absolute()}')
    print(f'Report Generated: {__import__(\"datetime\").datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")}')
    print()
    
    # Core data recovery capability
    print('üîµ CORE DATA RECOVERY')
    print('-' * 30)
    
    prayers_dir = archive_dir / 'prayers'
    users_dir = archive_dir / 'users'
    activity_dir = archive_dir / 'activity'
    
    if prayers_dir.exists():
        prayer_files = list(prayers_dir.rglob('*.txt'))
        print(f'‚úÖ Prayer archives: {len(prayer_files)} files')
    else:
        print('‚ùå Prayer archives: missing')
    
    if users_dir.exists():
        user_files = list(users_dir.glob('*.txt'))
        print(f'‚úÖ User archives: {len(user_files)} files')
    else:
        print('‚ùå User archives: missing')
    
    if activity_dir.exists():
        activity_files = list(activity_dir.glob('*.txt'))
        print(f'‚úÖ Activity archives: {len(activity_files)} files')
    else:
        print('‚ùå Activity archives: missing')
    
    print()
    
    # Enhanced data recovery capability
    print('üü° ENHANCED DATA RECOVERY')
    print('-' * 30)
    
    auth_dir = archive_dir / 'auth'
    roles_dir = archive_dir / 'roles'
    system_dir = archive_dir / 'system'
    
    if auth_dir.exists():
        auth_files = list(auth_dir.rglob('*.txt'))
        print(f'‚úÖ Authentication archives: {len(auth_files)} files')
    else:
        print('‚ö†Ô∏è  Authentication archives: missing (will use defaults)')
    
    if roles_dir.exists():
        role_files = list(roles_dir.glob('*.txt'))
        print(f'‚úÖ Role system archives: {len(role_files)} files')
    else:
        print('‚ö†Ô∏è  Role system archives: missing (will create defaults)')
    
    if system_dir.exists():
        system_files = list(system_dir.glob('*.txt'))
        print(f'‚úÖ System state archives: {len(system_files)} files')
    else:
        print('‚ö†Ô∏è  System state archives: missing (will use defaults)')
    
    print()
    
    # Enhanced prayer metadata
    print('üü¢ PRAYER METADATA RECOVERY')
    print('-' * 30)
    
    if prayers_dir.exists():
        attrs_dir = prayers_dir / 'attributes'
        marks_dir = prayers_dir / 'marks'
        skips_dir = prayers_dir / 'skips'
        
        if attrs_dir.exists():
            attr_files = list(attrs_dir.glob('*.txt'))
            print(f'‚úÖ Prayer attributes: {len(attr_files)} files')
        else:
            print('‚ö†Ô∏è  Prayer attributes: missing')
        
        if marks_dir.exists():
            mark_files = list(marks_dir.glob('*.txt'))
            print(f'‚úÖ Prayer marks: {len(mark_files)} files')
        else:
            print('‚ö†Ô∏è  Prayer marks: missing')
        
        if skips_dir.exists():
            skip_files = list(skips_dir.glob('*.txt'))
            print(f'‚úÖ Prayer skips: {len(skip_files)} files')
        else:
            print('‚ö†Ô∏è  Prayer skips: missing')
    
    print()
    
    # Recovery recommendations
    print('üí° RECOVERY RECOMMENDATIONS')
    print('-' * 30)
    
    has_core = prayers_dir.exists() and users_dir.exists()
    has_enhanced = auth_dir.exists() and roles_dir.exists()
    
    if has_core and has_enhanced:
        print('üéâ Complete recovery capability available!')
        print('   All data types can be fully reconstructed.')
        print('   Recommended: Run \"thywill test-recovery\" to validate.')
    elif has_core:
        print('‚úÖ Core recovery capability available!')
        print('   Basic prayer and user data can be reconstructed.')
        print('   Authentication and roles will use defaults.')
        print('   Recommended: Run \"thywill test-recovery\" to validate.')
    else:
        print('‚ö†Ô∏è  Limited recovery capability.')
        print('   Missing critical archive files.')
        print('   Recommended: Check archive generation and run backup.')
    
    print()
    print('üìã Use \"thywill test-recovery\" to simulate complete recovery')
    print('üìã Use \"thywill validate-archives\" for detailed validation')
    
except Exception as e:
    print(f'‚ùå Report generation failed: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
"
}

# Database commands
cmd_db() {
    local subcommand="${1:-}"
    shift || true
    
    case "$subcommand" in
        init)
            cmd_db_init "$@"
            ;;
        *)
            error "Unknown database subcommand: $subcommand"
            echo "Available subcommands: init"
            echo "Usage: thywill db <subcommand> [args]"
            echo ""
            echo "Examples:"
            echo "  thywill db init        # Initialize database tables (first time only)"
            exit 1
            ;;
    esac
}

cmd_migrate() {
    local subcommand="${1:-}"
    shift || true
    
    case "$subcommand" in
        ""|legacy)
            cmd_migrate_legacy "$@"
            ;;
        new)
            cmd_migrate_new "$@"
            ;;
        status)
            cmd_migrate_status "$@"
            ;;
        rollback)
            cmd_migrate_rollback "$@"
            ;;
        *)
            error "Unknown migrate subcommand: $subcommand"
            echo "Available subcommands: new, status, rollback, legacy"
            echo "Usage: thywill migrate <subcommand> [args]"
            echo ""
            echo "Examples:"
            echo "  thywill migrate new        # Run enhanced schema-only migrations"
            echo "  thywill migrate status     # Show migration status"
            echo "  thywill migrate rollback   # Rollback last migration"
            echo "  thywill migrate            # Run legacy migrations (old system)"
            exit 1
            ;;
    esac
}

cmd_migrate_legacy() {
    header "Running Legacy Database Migrations"
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ]; then
        error "models.py not found in current directory"
        echo "Please run this command from your ThyWill project directory"
        exit 1
    fi
    
    log "Running database migrations..."
    
    # Run the migration through Python
    if run_python -c "
from app_helpers.utils.database_helpers import migrate_database
try:
    migrate_database()
    print('Migration completed successfully')
except Exception as e:
    print(f'Migration failed: {e}')
    exit(1)
"; then
        success "Database migration completed successfully"
    else
        error "Database migration failed"
        exit 1
    fi
}

cmd_migrate_new() {
    header "Running Enhanced Schema-Only Migrations"
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ]; then
        error "models.py not found in current directory"
        echo "Please run this command from your ThyWill project directory"
        exit 1
    fi
    
    log "Running enhanced migrations..."
    
    # Run the enhanced migration system
    run_python -c "
import sys
sys.path.append('.')
from app_helpers.utils.enhanced_migration import MigrationManager

try:
    manager = MigrationManager()
    applied = manager.auto_migrate_on_startup()
    
    if applied:
        print(f'‚úÖ Successfully applied {len(applied)} migrations:')
        for migration in applied:
            print(f'   - {migration}')
    else:
        print('‚úÖ Database is up to date - no migrations needed')
        
except Exception as e:
    print(f'‚ùå Migration failed: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
"
    
    if [ $? -eq 0 ]; then
        success "Enhanced migrations completed successfully"
    else
        error "Enhanced migrations failed"
        exit 1
    fi
}

cmd_migrate_status() {
    header "Migration Status"
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ]; then
        error "models.py not found in current directory"
        echo "Please run this command from your ThyWill project directory"
        exit 1
    fi
    
    # Show migration status
    run_python -c "
import sys
sys.path.append('.')
from app_helpers.utils.enhanced_migration import MigrationManager

try:
    manager = MigrationManager()
    
    # Get current version
    current = manager.get_current_version()
    if current:
        print(f'üìä Current schema version: {current}')
    else:
        print('üìä No migrations applied yet')
    
    # Get applied migrations
    applied = manager.get_applied_migrations()
    if applied:
        print(f'‚úÖ Applied migrations ({len(applied)}):')
        for migration in applied:
            print(f'   - {migration}')
    else:
        print('‚ÑπÔ∏è  No migrations applied yet')
    
    print()
    
    # Get pending migrations
    pending = manager.get_pending_migrations()
    if pending:
        print(f'‚è≥ Pending migrations ({len(pending)}):')
        for migration in pending:
            metadata = migration['metadata']
            estimated_time = manager.estimate_migration_time(migration)
            maintenance_mode = manager.should_enable_maintenance_mode(migration)
            
            print(f'   - {migration[\"id\"]}')
            print(f'     Description: {metadata.get(\"description\", \"No description\")}')
            print(f'     Estimated time: {estimated_time}s')
            if maintenance_mode:
                print(f'     ‚ö†Ô∏è  Requires maintenance mode')
            print()
    else:
        print('‚úÖ No pending migrations - database is up to date')
    
    # Schema integrity check
    print('üîç Schema integrity check:')
    if manager.validate_schema_integrity():
        print('   ‚úÖ Database integrity verified')
    else:
        print('   ‚ùå Database integrity check failed')
        
except Exception as e:
    print(f'‚ùå Error checking migration status: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
"
}

cmd_migrate_rollback() {
    local migration_id="${1:-}"
    
    header "Rolling Back Migration"
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ]; then
        error "models.py not found in current directory"
        echo "Please run this command from your ThyWill project directory"
        exit 1
    fi
    
    if [ -z "$migration_id" ]; then
        # Show available migrations to rollback
        warning "No migration ID specified. Finding last applied migration..."
        
        migration_id=$(run_python -c "
import sys
sys.path.append('.')
from app_helpers.utils.enhanced_migration import MigrationManager

try:
    manager = MigrationManager()
    current = manager.get_current_version()
    if current:
        print(current)
    else:
        print('')
except:
    print('')
")
        
        if [ -z "$migration_id" ]; then
            error "No migrations found to rollback"
            echo "Use 'thywill migrate status' to see applied migrations"
            exit 1
        fi
        
        log "Found last migration: $migration_id"
        read -p "Rollback this migration? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            warning "Rollback cancelled"
            exit 0
        fi
    fi
    
    log "Rolling back migration: $migration_id"
    
    # Perform rollback
    run_python -c "
import sys
sys.path.append('.')
from app_helpers.utils.enhanced_migration import MigrationManager

migration_id = '$migration_id'

try:
    manager = MigrationManager()
    
    if not manager.acquire_migration_lock():
        print('‚ùå Could not acquire migration lock - another migration may be in progress')
        sys.exit(1)
    
    try:
        if manager.rollback_migration(migration_id):
            print(f'‚úÖ Successfully rolled back migration: {migration_id}')
        else:
            print(f'‚ùå Failed to rollback migration: {migration_id}')
            sys.exit(1)
    finally:
        manager.release_migration_lock()
        
except Exception as e:
    print(f'‚ùå Rollback failed: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
"
    
    if [ $? -eq 0 ]; then
        success "Migration rollback completed successfully"
        log "Run 'thywill migrate status' to verify the rollback"
    else
        error "Migration rollback failed"
        exit 1
    fi
}

cmd_db_init() {
    header "Database Initialization"
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ]; then
        error "models.py not found in current directory"
        echo "Please run this command from your ThyWill project directory"
        exit 1
    fi
    
    # Check if create_database.py exists
    if [ ! -f "create_database.py" ]; then
        error "create_database.py script not found"
        echo "Please ensure the database creation script is in the project directory"
        exit 1
    fi
    
    log "Running database initialization script..."
    echo ""
    
    # Execute the standalone database creation script
    run_python create_database.py
    
    if [ $? -eq 0 ]; then
        echo ""
        success "Database initialization completed!"
        echo ""
        echo "Next steps:"
        echo "  thywill start          # Start development server"
        echo "  thywill admin token    # Create first admin account"
    else
        echo ""
        error "Database initialization failed"
        echo "Check the error messages above for details"
        exit 1
    fi
}

cmd_sqlite() {
    header "Opening SQLite3 Database Shell"
    
    # Check if we're in the right directory
    if [ ! -f "thywill.db" ]; then
        error "Database file 'thywill.db' not found in current directory"
        echo "Please run this command from your ThyWill project directory"
        echo "If database doesn't exist, run: thywill db init"
        exit 1
    fi
    
    # Check if sqlite3 is installed
    if ! command -v sqlite3 >/dev/null 2>&1; then
        error "sqlite3 command not found"
        echo "Please install sqlite3:"
        echo "  Ubuntu/Debian: sudo apt install sqlite3"
        echo "  macOS: brew install sqlite3"
        exit 1
    fi
    
    log "Opening thywill.db with SQLite3..."
    log "Helpful commands will be shown after connecting"
    echo ""
    
    # Create a temporary init file with helpful settings and commands
    temp_init=$(mktemp)
    cat > "$temp_init" << 'EOF'
-- SQLite3 helpful settings
.headers on
.mode column
.width 20 40 20 15

-- Show helpful information
.print "üóÑÔ∏è  ThyWill Database Shell"
.print "================================"
.print ""
.print "üìã Available Tables:"
.tables
.print ""
.print "üí° Helpful Commands:"
.print "  .tables                    -- List all tables"
.print "  .schema TABLE_NAME         -- Show table structure"
.print "  .schema                    -- Show all table schemas"
.print "  .headers on|off            -- Toggle column headers"
.print "  .mode column|list|csv      -- Change output format"
.print "  .width 10 20 30            -- Set column widths"
.print "  .help                      -- Show all SQLite commands"
.print "  .quit or .exit             -- Exit SQLite shell"
.print ""
.print "üîç Quick Queries:"
.print "  SELECT COUNT(*) FROM user;              -- Count users"
.print "  SELECT COUNT(*) FROM prayer;            -- Count prayers"
.print "  SELECT display_name FROM user LIMIT 5;  -- Show first 5 users"
.print "  SELECT text FROM prayer LIMIT 3;        -- Show first 3 prayers"
.print ""
.print "Ready! Type your SQL commands below:"
.print ""
EOF
    
    # Launch sqlite3 with the init file
    sqlite3 -init "$temp_init" thywill.db
    
    # Clean up temp file
    rm -f "$temp_init"
    
    echo ""
    success "SQLite3 session ended"
}

# Utility commands
cmd_setup() {
    header "ThyWill Complete Ubuntu Setup"
    
    log "This will install all required packages and set up the development environment"
    echo ""
    warning "This command will:"
    echo "  1. Update apt packages"
    echo "  2. Install Python 3, pip, venv, nginx, sqlite3"
    echo "  3. Create virtual environment"
    echo "  4. Install Python dependencies"
    echo "  5. Set up database"
    echo "  6. Configure systemd service"
    echo "  7. Set up nginx (optional)"
    echo "  8. Initialize backup system"
    echo ""
    
    read -p "Continue with setup? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        warning "Setup cancelled"
        exit 0
    fi
    
    # Step 1: Update system packages
    header "Step 1: Updating system packages"
    sudo apt update
    
    # Step 2: Install system dependencies
    header "Step 2: Installing system dependencies"
    sudo apt install -y python3 python3-pip python3-venv python3-dev \
                        sqlite3 nginx curl git build-essential \
                        software-properties-common
    
    # Step 3: Create Python virtual environment
    header "Step 3: Setting up Python virtual environment"
    if [ ! -d "venv" ]; then
        log "Creating virtual environment..."
        python3 -m venv venv
    else
        log "Virtual environment already exists"
    fi
    
    # Step 4: Install Python dependencies
    header "Step 4: Installing Python dependencies"
    source venv/bin/activate
    pip install --upgrade pip
    pip install -r requirements.txt
    
    # Step 5: Initialize database
    header "Step 5: Setting up database"
    if [ ! -f "thywill.db" ]; then
        log "Creating database..."
        python -c "
from models import create_db_and_tables
create_db_and_tables()
print('Database created successfully')
"
    else
        log "Database already exists"
    fi
    
    # Step 6: Set up production user (if we're setting up for production)
    if [ "$USER" != "thywill" ] && [ "$PWD" != "/home/thywill/thywill" ]; then
        header "Step 6: Development setup complete!"
        success "Development environment ready!"
        echo ""
        echo "Next steps:"
        echo "  thywill start          # Start development server"
        echo "  thywill install        # Install CLI globally"
        echo ""
        echo "For production setup on this server:"
        echo "  sudo adduser thywill"
        echo "  sudo cp -r . /home/thywill/thywill"
        echo "  sudo chown -R thywill:thywill /home/thywill/thywill"
        echo "  thywill setup-production"
    else
        header "Step 6: Setting up production environment"
        cmd_setup_production
    fi
}

cmd_setup_production() {
    header "Production Environment Setup"
    
    # Create required directories
    log "Creating directories..."
    sudo mkdir -p /home/thywill/backups/{hourly,daily,weekly}
    sudo mkdir -p /home/thywill/deploy_logs
    sudo mkdir -p /home/thywill/logs
    sudo chown -R thywill:thywill /home/thywill/
    
    # Set up systemd service
    log "Setting up systemd service..."
    sudo cp deployment/thywill.service /etc/systemd/system/
    sudo systemctl daemon-reload
    sudo systemctl enable thywill
    
    # Prompt for nginx setup
    echo ""
    log "Nginx configuration options:"
    echo "1) Domain-based (recommended for production)"
    echo "2) IP-only access"
    echo "3) Skip nginx setup"
    read -p "Choose option (1-3): " nginx_choice
    
    case $nginx_choice in
        1)
            read -p "Enter your domain name: " domain_name
            if [ -n "$domain_name" ]; then
                sed "s/your-domain.com/$domain_name/g" deployment/nginx-domain.conf > /tmp/thywill-nginx.conf
                sudo cp /tmp/thywill-nginx.conf /etc/nginx/sites-available/thywill
                sudo ln -sf /etc/nginx/sites-available/thywill /etc/nginx/sites-enabled/
                sudo nginx -t && sudo systemctl reload nginx
                success "Nginx configured for domain: $domain_name"
            fi
            ;;
        2)
            sudo cp deployment/nginx-ip-only.conf /etc/nginx/sites-available/thywill
            sudo ln -sf /etc/nginx/sites-available/thywill /etc/nginx/sites-enabled/
            sudo nginx -t && sudo systemctl reload nginx
            success "Nginx configured for IP access"
            ;;
        3)
            log "Skipping nginx setup"
            ;;
    esac
    
    # Set up environment file
    if [ ! -f ".env" ]; then
        log "Creating environment file..."
        cp deployment/sample.env .env
        warning "Please edit .env file with your actual values"
    fi
    
    # Set up automated backups
    log "Setting up automated backups..."
    if ! crontab -l 2>/dev/null | grep -q "thywill"; then
        log "Adding crontab entries..."
        (crontab -l 2>/dev/null; cat deployment/crontab_backups.txt) | crontab -
        success "Automated backups configured"
    else
        log "Backup crontab already configured"
    fi
    
    # Start service
    log "Starting ThyWill service..."
    sudo systemctl start thywill
    
    # Final verification
    sleep 3
    if systemctl is-active --quiet thywill; then
        success "ThyWill service is running!"
        if curl -s http://127.0.0.1:8000/health > /dev/null 2>&1; then
            success "Health check passed!"
        else
            warning "Service running but health check failed - check logs"
        fi
    else
        error "Service failed to start - check logs"
        echo "Run: journalctl -u thywill -n 20"
    fi
    
    echo ""
    success "Production setup complete!"
    echo ""
    echo "Service status: $(systemctl is-active thywill)"
    echo "View logs: thywill logs"
    echo "Check health: thywill health"
    echo "Create backup: thywill backup"
}

cmd_init() {
    header "Initializing ThyWill Deployment Environment"
    
    log "Creating required directories..."
    sudo mkdir -p /home/thywill/backups/{hourly,daily,weekly}
    sudo mkdir -p /home/thywill/deploy_logs
    sudo mkdir -p /home/thywill/logs
    
    if id "thywill" &>/dev/null; then
        sudo chown -R thywill:thywill /home/thywill/backups
        sudo chown -R thywill:thywill /home/thywill/deploy_logs
        sudo chown -R thywill:thywill /home/thywill/logs
        success "Directory ownership set to thywill user"
    else
        warning "User 'thywill' not found. Please set proper ownership manually."
    fi
    
    log "Making scripts executable..."
    chmod +x "$DEPLOYMENT_DIR"/*.sh
    chmod +x "$DEPLOYMENT_DIR"/*.py
    
    log "Setting up automated backups..."
    if [ -f "$DEPLOYMENT_DIR/crontab_backups.txt" ]; then
        echo ""
        warning "To complete setup, add these crontab entries:"
        echo "Run: crontab -e"
        echo "Then add the following lines:"
        echo ""
        cat "$DEPLOYMENT_DIR/crontab_backups.txt"
        echo ""
    fi
    
    success "ThyWill deployment environment initialized!"
    echo ""
    echo "Next steps:"
    echo "1. Set up crontab entries for automated backups"
    echo "2. Test deployment: thywill deploy"
    echo "3. Test backup: thywill backup"
}

cmd_config() {
    header "Current Configuration"
    
    echo ""
    echo "Paths:"
    echo "  Application Directory: $APP_DIR"
    echo "  Backup Directory: $BACKUP_DIR"
    echo "  Deployment Scripts: $DEPLOYMENT_DIR"
    echo ""
    
    echo "Service Status:"
    if systemctl is-active --quiet thywill; then
        echo "  ThyWill Service: RUNNING"
    else
        echo "  ThyWill Service: STOPPED"
    fi
    
    echo ""
    echo "Available Scripts:"
    ls -la "$DEPLOYMENT_DIR"/*.sh "$DEPLOYMENT_DIR"/*.py 2>/dev/null | while read -r line; do
        echo "  $line"
    done
    
    echo ""
    echo "Backup Statistics:"
    if [ -d "$BACKUP_DIR" ]; then
        echo "  Hourly backups: $(find $BACKUP_DIR/hourly -name "*.db" 2>/dev/null | wc -l)"
        echo "  Daily backups: $(find $BACKUP_DIR/daily -name "*.db" 2>/dev/null | wc -l)"
        echo "  Weekly backups: $(find $BACKUP_DIR/weekly -name "*.db" 2>/dev/null | wc -l)"
        
        local total_size
        total_size=$(du -sh "$BACKUP_DIR" 2>/dev/null | cut -f1 || echo "Unknown")
        echo "  Total backup size: $total_size"
    else
        echo "  Backup directory not found"
    fi
}

cmd_install() {
    header "Installing ThyWill CLI Globally"
    
    local script_path="$SCRIPT_DIR/thywill"
    local install_path="/usr/local/bin/thywill"
    
    if [ ! -f "$script_path" ]; then
        error "ThyWill CLI script not found at: $script_path"
        exit 1
    fi
    
    log "Installing thywill to $install_path..."
    
    # Create the symlink
    if sudo ln -sf "$script_path" "$install_path"; then
        success "ThyWill CLI installed successfully!"
        echo ""
        echo "You can now use 'thywill' from anywhere (no more ./)"
        echo ""
        echo "Try it out:"
        echo "  thywill help"
        echo "  thywill status"
        echo "  thywill config"
    else
        error "Failed to install ThyWill CLI"
        exit 1
    fi
}

cmd_uninstall() {
    header "Uninstalling ThyWill CLI"
    
    local install_path="/usr/local/bin/thywill"
    
    if [ ! -L "$install_path" ] && [ ! -f "$install_path" ]; then
        warning "ThyWill CLI is not installed globally"
        echo "Use ./thywill to run from current directory"
        return 0
    fi
    
    log "Removing $install_path..."
    
    if sudo rm -f "$install_path"; then
        success "ThyWill CLI uninstalled successfully!"
        echo ""
        echo "You'll need to use './thywill' to run from the project directory"
    else
        error "Failed to uninstall ThyWill CLI"
        exit 1
    fi
}

# Duplicate user management commands
cmd_check_duplicates() {
    header "Checking for Duplicate Users"
    
    # Check if we're in the right directory
    if [ ! -f "models.py" ] && [ ! -f "thywill.db" ]; then
        error "Must run from ThyWill project directory"
        echo "Database or models.py not found"
        exit 1
    fi
    
    run_python -c "
import sys
sys.path.append('.')
from sqlmodel import Session, text
from models import engine

with Session(engine) as session:
    # Find duplicate usernames
    result = session.exec(text('''
        SELECT display_name, COUNT(*) as count 
        FROM user 
        GROUP BY display_name 
        HAVING COUNT(*) > 1
        ORDER BY count DESC
    '''))
    
    duplicates = result.fetchall()
    
    if not duplicates:
        print('‚úÖ No duplicate usernames found')
        sys.exit(0)
    
    print(f'‚ö†Ô∏è  Found {len(duplicates)} usernames with duplicates:')
    for username, count in duplicates:
        print(f'   \"{username}\": {count} users')
    
    # Get specific user IDs for each duplicate
    for username, count in duplicates:
        stmt = text('''
            SELECT id, created_at, invited_by_user_id 
            FROM user 
            WHERE display_name = :username 
            ORDER BY created_at
        ''').bindparam(username=username)
        users = session.exec(stmt).fetchall()
        
        print(f'\\nüìã Users with username \"{username}\":')
        for i, (user_id, created_at, invited_by) in enumerate(users):
            marker = 'üëë PRIMARY' if i == 0 else 'üîÑ DUPLICATE'
            print(f'   {marker}: {user_id} (created: {created_at})')
"
}

cmd_merge_duplicates() {
    header "Merging Duplicate Users"
    
    # Check if we're in the right directory  
    if [ ! -f "models.py" ] && [ ! -f "thywill.db" ]; then
        error "Must run from ThyWill project directory"
        echo "Database or models.py not found"
        exit 1
    fi
    
    # Check for duplicates first (suppress extra output)
    duplicates_found=$(PRODUCTION_MODE=1 python3 -c "
import sys
sys.path.append('.')
from sqlmodel import Session, text
from models import engine

with Session(engine) as session:
    result = session.exec(text('''
        SELECT COUNT(*) as duplicate_count
        FROM (
            SELECT display_name, COUNT(*) as count 
            FROM user 
            GROUP BY display_name 
            HAVING COUNT(*) > 1
        )
    '''))
    
    count = result.fetchone()[0]
    print(count)
" 2>/dev/null)

    if [ "$duplicates_found" -eq 0 ]; then
        echo "‚úÖ No duplicate users found - nothing to merge"
        return 0
    fi
    
    echo "‚ö†Ô∏è  Found $duplicates_found duplicate usernames. This will:"
    echo "   - Merge duplicate user accounts"
    echo "   - Preserve all data (prayers, sessions, etc.)"
    echo "   - Keep the oldest account as primary"
    echo "   - Add unique constraint to prevent future duplicates"
    echo ""
    
    read -p "Proceed with duplicate user merge? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Merge cancelled"
        return 0
    fi
    
    # Create backup first
    backup_file="thywill_backup_$(date +%Y%m%d_%H%M%S).db"
    log "Creating backup: $backup_file"
    cp thywill.db "$backup_file"
    
    # Run the migration inline
    run_python -c "
import sys
sys.path.append('.')
from sqlmodel import Session, select, text
from models import engine, User, Prayer, Session as UserSession, PrayerMark, PrayerSkip
from datetime import datetime

def merge_duplicate_users():
    with Session(engine) as session:
        try:
            # Find all duplicate usernames
            duplicates_result = session.exec(text('''
                SELECT display_name, COUNT(*) as count 
                FROM user 
                GROUP BY display_name 
                HAVING COUNT(*) > 1
                ORDER BY count DESC
            '''))
            
            duplicates = duplicates_result.fetchall()
            merged_count = 0
            
            for username, count in duplicates:
                print(f'üîÑ Merging {count} users with username: {username}')
                
                # Get all users with this username, ordered by creation date (oldest first)
                stmt = text('''
                    SELECT id, created_at 
                    FROM user 
                    WHERE display_name = :username 
                    ORDER BY created_at ASC
                ''').bindparam(username=username)
                users = session.exec(stmt).fetchall()
                
                if len(users) < 2:
                    continue
                    
                primary_user_id = users[0][0]  # Keep the oldest user
                duplicate_user_ids = [user[0] for user in users[1:]]  # Mark others for merging
                
                print(f'   Primary user: {primary_user_id} (keeping)')
                for dup_id in duplicate_user_ids:
                    print(f'   Merging: {dup_id} -> {primary_user_id}')
                
                # Update prayers
                for dup_id in duplicate_user_ids:
                    stmt = text('UPDATE prayer SET author_id = :primary WHERE author_id = :dup').bindparam(primary=primary_user_id, dup=dup_id)
                    session.exec(stmt)
                
                # Update sessions
                for dup_id in duplicate_user_ids:
                    stmt = text('UPDATE session SET user_id = :primary WHERE user_id = :dup').bindparam(primary=primary_user_id, dup=dup_id)
                    session.exec(stmt)
                
                # Update prayer marks
                for dup_id in duplicate_user_ids:
                    stmt = text('UPDATE prayermark SET user_id = :primary WHERE user_id = :dup').bindparam(primary=primary_user_id, dup=dup_id)
                    session.exec(stmt)
                
                # Update prayer skips
                for dup_id in duplicate_user_ids:
                    stmt = text('UPDATE prayerskip SET user_id = :primary WHERE user_id = :dup').bindparam(primary=primary_user_id, dup=dup_id)
                    session.exec(stmt)
                
                # Delete duplicate users
                for dup_id in duplicate_user_ids:
                    stmt = text('DELETE FROM user WHERE id = :dup').bindparam(dup=dup_id)
                    session.exec(stmt)
                
                merged_count += len(duplicate_user_ids)
            
            session.commit()
            print(f'‚úÖ Successfully merged {merged_count} duplicate users')
            return True
            
        except Exception as e:
            session.rollback()
            print(f'‚ùå Error during merge: {e}')
            import traceback
            traceback.print_exc()
            return False

if merge_duplicate_users():
    sys.exit(0)
else:
    sys.exit(1)
"
    
    if [ $? -eq 0 ]; then
        success "Duplicate users merged successfully"
        echo "Backup saved as: $backup_file"
    else
        error "Merge failed - database unchanged"
        rm -f "$backup_file" 2>/dev/null
        exit 1
    fi
}

# Main command dispatcher
main() {
    local command="${1:-help}"
    shift || true
    
    case "$command" in
        # Development commands
        start)
            cmd_start "$@"
            ;;
        
        # Deployment commands
        deploy)
            cmd_deploy "$@"
            ;;
        rollback)
            cmd_rollback "$@"
            ;;
        health)
            cmd_health "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        logs)
            cmd_logs "$@"
            ;;
        
        # Backup commands
        backup)
            cmd_backup "$@"
            ;;
        list)
            cmd_list "$@"
            ;;
        restore)
            cmd_restore "$@"
            ;;
        cleanup)
            cmd_cleanup "$@"
            ;;
        verify)
            cmd_verify "$@"
            ;;
        
        # Admin commands
        admin)
            cmd_admin "$@"
            ;;
        role)
            cmd_role "$@"
            ;;
        import)
            cmd_import "$@"
            ;;
        validate-archives)
            cmd_validate_archives "$@"
            ;;
        test-recovery)
            cmd_test_recovery "$@"
            ;;
        full-recovery)
            cmd_full_recovery "$@"
            ;;
        repair-archives)
            cmd_repair_archives "$@"
            ;;
        heal-archives)
            cmd_heal_archives "$@"
            ;;
        sync-archives)
            cmd_sync_archives "$@"
            ;;
        recovery-report)
            cmd_recovery_report "$@"
            ;;
        
        # Database commands
        db)
            cmd_db "$@"
            ;;
        migrate)
            cmd_migrate "$@"
            ;;
        sqlite)
            cmd_sqlite "$@"
            ;;
        
        # Duplicate user management commands
        check-duplicates)
            cmd_check_duplicates "$@"
            ;;
        merge-duplicates)
            cmd_merge_duplicates "$@"
            ;;
        
        # Utility commands
        setup)
            cmd_setup "$@"
            ;;
        init)
            cmd_init "$@"
            ;;
        install)
            cmd_install "$@"
            ;;
        uninstall)
            cmd_uninstall "$@"
            ;;
        config)
            cmd_config "$@"
            ;;
        help|--help|-h)
            show_help
            ;;
        version|--version|-v)
            show_version
            ;;
        
        *)
            error "Unknown command: $command"
            echo ""
            echo "Use 'thywill help' to see available commands"
            exit 1
            ;;
    esac
}

# Execute main function with all arguments
main "$@"